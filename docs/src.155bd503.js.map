{"version":3,"sources":["src/consts.js","src/abstractController.js","src/inputHandler.js","src/unitBase.js","src/grid.js","src/effects/effectStartPhase.js","src/enemyAI.js","src/pathFinder.js","src/stage.js","src/stages/stage01.js","src/game.js","src/index.js"],"names":["consts","terrainTypes","Nrm","Mnt","Wtr","Wll","buttons","TurnEnd","Wait","gameResult","None","Win","Lose","CTRL_STATE_NONE","CTRL_STATE_SELECTED","CTRL_STATE_DEST_CHOSEN","CTRL_STATE_TARGET_CHOSEN","AbstractController","game","isEnemy","hGame","ctrlState","currentUnit","currentDest","currentTarget","eventDeselect","gp","eventProposeDestination","unit","eventProposeTarget","eventBeTargeted","buttonID","eventExecuteWait","stateDeselect","x","maxGrid","y","findSelfUnitByGridPos","isActive","eventSelect","findOppoUnitByGridPos","findUnitByGridPos","checkMoveDestination","stateConfirmDestination","checkAttackTarget","gridPos","localAlert","stateConfirmTarget","eventExecuteMovement","eventExecuteAttack","eventStopBeingTargeted","str","InputHandler","hCanvas","abstractController","clickPosQueue","isMobile","test","navigator","userAgent","isApple","touchEvent","document","addEventListener","event","mouseClick","getMousePosWithinCanvas","preventDefault","undefined","touches","rect","getBoundingClientRect","clientX","left","right","width","clientY","top","bottom","height","pos","isPhaseBlocked","currentPhase","PHASE_PLAYER","push","df","length","clickGP","posToGridPos","shift","UnitBase","unitID","imageId","image","getElementById","coordinate","gridPosToPos","imageSize","gridSize","hp","attack","alive","stamina","staminaMax","moveDist","moveDistMax","attackRange","pathData","resetControlState","resetProposal","drawScale","isSelected","isTargeted","hasDestProposal","destProposalGP","destProposalCoord","pathToDestProposal","pathToDestProposalCoord","hasTargetProposal","targetProposal","updatePathData","pathFinder","floodFill","stage","getTerrain","Math","abs","isReachable","path","len","i","destGP","acceptPath","retrievePath","eventActionExecuted","executeAction","eventBattle","damage","eventUnitDeath","PHASE_ENEMY","ctx","fillStyle","isInPhase","fillRect","drawImage","Grid","xMax","yMax","lineHalfWidth","effectStartPhase","isEnemyPhase","frame","maxFrame","drawX","gameWidth","drawY","eventEffectEnd","dx","dy","EnemyAI","suList","enemyUnitList","ouList","playerUnitList","absCon","blockFrameRemain","blockFramePerAttack","blockFramePerMove","blockFramePerWait","clickButton","dest","target","suIdx","su","listPossibleDest","forEach","executeMoveAttack","minDist","bestGP","wideSearch","distTarget","dist","executeMove","res","findOppoUnitAndAttack","tryGetClose","executeWait","makeOneMove","MAX_DIST","PathFinder","eList","pList","hStage","visited","startGP","searchRange","flagIgnoreUnit","prev","j","queue","head","tail","xNew","yNew","gpNew","checkPassable","goalGP","T","Stage","terrainMap","unitList","imageCache","appearTurn","eventPlaceUnit","turn","Game","gameHeight","canvas","PHASE_NONE","grid","effectList","totalActiveStamina","framesBeforeChangePhase","enemyAI","inputHandler","playerInputHandler","Stage01","initStage","playerPhase","endPhase","object","eventSenjoUpdated","eventNewTurn","endTurn","EffectStartPhase","enemyPhase","findUnitInListByGridPos","findEnemyUnitByGridPos","findPlayerUnitByGridPos","attacker","eventLoseHP","removeObjectFromList","effect","procChangePhase","update","draw","drawUnitBG","drawUnit","floor","list","splice","getContext","GAME_WIDTH","GAME_HEIGHT","bindPlayerInputHandler","start","lastTime","gameLoop","timestamp","dt","clearRect","requestAnimationFrame","alert"],"mappings":"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","file":"src.155bd503.js","sourceRoot":"..","sourcesContent":["const consts = {\r\n    terrainTypes: {\r\n        Nrm: 0, // normal\r\n        Mnt: 1, // mountain\r\n        Wtr: 2, // water\r\n        Wll: 3 // wall\r\n    },\r\n    buttons: {\r\n        TurnEnd: 0,\r\n        Wait: 1\r\n    },\r\n    gameResult: {\r\n        None: 0,\r\n        Win: 1,\r\n        Lose: 2\r\n    }\r\n};\r\nexport default consts;\r\n","import consts from \"/src/consts\";\r\n\r\nconst CTRL_STATE_NONE = 0; // no player unit selected (can have enemy unit selected)\r\nconst CTRL_STATE_SELECTED = 1; // player unit selected\r\nconst CTRL_STATE_DEST_CHOSEN = 2; // move pos selected\r\nconst CTRL_STATE_TARGET_CHOSEN = 3; // attack target selected, one more click to execute\r\n\r\n// this shit will be used by both player and AI\r\n// AI use it by faking clicks. It'll be a longer seq of codes for AI scripts but it will make sure consistency.\r\n// under such framework, AI should never call unit's event methods.\r\n\r\nexport default class AbstractController {\r\n    constructor(game, isEnemy) {\r\n        this.hGame = game;\r\n        this.isEnemy = isEnemy;\r\n        this.ctrlState = CTRL_STATE_NONE;\r\n        this.currentUnit = null;\r\n        this.currentDest = null;\r\n        this.currentTarget = null;\r\n    }\r\n\r\n    stateDeselect() {\r\n        this.currentUnit.eventDeselect();\r\n        this.currentUnit = null;\r\n        this.ctrlState = CTRL_STATE_NONE;\r\n    }\r\n\r\n    stateConfirmDestination(gp) {\r\n        this.currentDest = gp;\r\n        this.ctrlState = CTRL_STATE_DEST_CHOSEN;\r\n        this.currentUnit.eventProposeDestination(gp);\r\n    }\r\n\r\n    stateConfirmTarget(unit) {\r\n        this.ctrlState = CTRL_STATE_TARGET_CHOSEN;\r\n        this.currentTarget = unit;\r\n        this.currentUnit.eventProposeTarget(unit);\r\n        unit.eventBeTargeted(); // this doesn't seem right here, should be in Game or at least another class\r\n    }\r\n\r\n    clickButton(buttonID) {\r\n        if (buttonID === consts.buttons.TurnEnd) {\r\n            // do something\r\n        } else if (buttonID === consts.buttons.Wait) {\r\n            if (this.ctrlState === CTRL_STATE_NONE) {\r\n                return false;\r\n            } else {\r\n                this.currentUnit.eventExecuteWait();\r\n                this.stateDeselect();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    clickGP(gp) {\r\n        if (\r\n            gp.x < 1 ||\r\n            gp.x > this.hGame.maxGrid.x ||\r\n            gp.y < 1 ||\r\n            gp.y > this.hGame.maxGrid.y\r\n        ) {\r\n            //localAlert(\"the selected position is out of bound\");\r\n            return false;\r\n        }\r\n\r\n        if (this.ctrlState === CTRL_STATE_NONE) {\r\n            // no player unit selected before, check which unit to select now\r\n            if (this.currentUnit !== null) {\r\n                this.currentUnit.eventDeselect();\r\n                this.currentUnit = null;\r\n            }\r\n            let unit = this.hGame.findSelfUnitByGridPos(this.isEnemy, gp);\r\n            if (unit !== null) {\r\n                if (unit.isActive()) this.ctrlState = CTRL_STATE_SELECTED;\r\n                this.currentUnit = unit;\r\n                unit.eventSelect();\r\n            } else {\r\n                unit = this.hGame.findOppoUnitByGridPos(this.isEnemy, gp);\r\n                if (unit !== null) {\r\n                    this.currentUnit = unit;\r\n                    unit.eventSelect();\r\n                }\r\n            }\r\n            if (unit === null) {\r\n                //localAlert(\"No unit found\");\r\n                this.ctrlState = CTRL_STATE_NONE;\r\n                return false;\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_SELECTED) {\r\n            // player unit selected, check where to move now\r\n            let unit = this.hGame.findUnitByGridPos(gp);\r\n            if (unit === null && this.currentUnit.checkMoveDestination(gp)) {\r\n                this.stateConfirmDestination(gp);\r\n                return true;\r\n            } else {\r\n                if (\r\n                    unit !== null &&\r\n                    unit.isEnemy !== this.isEnemy &&\r\n                    this.currentUnit.checkAttackTarget(\r\n                        unit,\r\n                        this.currentUnit.gridPos\r\n                    )\r\n                ) {\r\n                    localAlert(\r\n                        \"selected an eligible target during dest proposition\"\r\n                    );\r\n                    this.stateConfirmDestination(this.currentUnit.gridPos);\r\n                    this.stateConfirmTarget(unit);\r\n                    return true;\r\n                } else {\r\n                    localAlert(\"invalid destination\");\r\n                    this.stateDeselect();\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_DEST_CHOSEN) {\r\n            // destination chosen, execute movement or find attack target.\r\n            let unit = this.hGame.findUnitByGridPos(gp);\r\n            if (\r\n                unit === null &&\r\n                gp.x === this.currentDest.x &&\r\n                gp.y === this.currentDest.y\r\n            ) {\r\n                // execute movement\r\n                this.currentUnit.eventExecuteMovement(gp);\r\n                this.stateDeselect();\r\n                return true;\r\n            } else {\r\n                if (\r\n                    unit !== null &&\r\n                    unit.isEnemy !== this.isEnemy &&\r\n                    this.currentUnit.checkAttackTarget(unit, this.currentDest)\r\n                ) {\r\n                    // target confirmed\r\n                    this.stateConfirmTarget(unit);\r\n                    return true;\r\n                } else {\r\n                    // invalid target\r\n                    this.stateDeselect();\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_TARGET_CHOSEN) {\r\n            if (\r\n                gp.x === this.currentTarget.gridPos.x &&\r\n                gp.y === this.currentTarget.gridPos.y\r\n            ) {\r\n                // execute attack\r\n                this.currentUnit.eventExecuteAttack(this.currentTarget);\r\n                this.currentTarget.eventStopBeingTargeted();\r\n                this.stateDeselect();\r\n                return true;\r\n            } else {\r\n                // not the same gridpos as proposed target, forfeit\r\n                this.currentTarget.eventStopBeingTargeted();\r\n                this.stateDeselect();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        localAlert(\r\n            \"this alert should not happen due to returns. x: \" +\r\n                gp.x +\r\n                \", y: \" +\r\n                gp.y +\r\n                \";  ctrl state: \" +\r\n                this.ctrlState\r\n        );\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction localAlert(str) {\r\n    // not sure if it really localise or is still global...\r\n    //alert(str);\r\n}\r\n","import AbstractController from \"./abstractController\";\r\n\r\nexport default class InputHandler {\r\n    constructor(game) {\r\n        this.hGame = game;\r\n        this.hCanvas = game.hCanvas;\r\n        this.abstractController = new AbstractController(game, false);\r\n        this.clickPosQueue = [];\r\n\r\n        // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\r\n        this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\r\n        this.isApple = /iPhone|iPad|iPod/i.test(navigator.userAgent);\r\n        let touchEvent = this.isMobile ? \"touchstart\" : \"click\";\r\n\r\n        document.addEventListener(touchEvent, event => {\r\n            this.mouseClick(this.getMousePosWithinCanvas(event));\r\n            if (this.isMobile) event.preventDefault();\r\n        });\r\n\r\n        if (this.isMobile) {\r\n            document.addEventListener(\"touchmove\", event => {\r\n                event.preventDefault();\r\n            });\r\n            document.addEventListener(\"touchend\", event => {\r\n                event.preventDefault();\r\n            });\r\n        }\r\n    }\r\n\r\n    getMousePosWithinCanvas(event) {\r\n        // https://stackoverflow.com/questions/9585487/cant-get-coordinates-of-touchevents-in-javascript-on-android-devices\r\n        // holy crap so if it's a TouchEvent then it can capture more than one touch and store them into an array\r\n        // ah yeah so that's probably how multi-touch works. make sense\r\n        if (event.touches !== undefined) event = event.touches[0];\r\n\r\n        // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas\r\n        let rect = this.hCanvas.getBoundingClientRect();\r\n        return {\r\n            x:\r\n                ((event.clientX - rect.left) / (rect.right - rect.left)) *\r\n                this.hCanvas.width,\r\n            y:\r\n                ((event.clientY - rect.top) / (rect.bottom - rect.top)) *\r\n                this.hCanvas.height\r\n        };\r\n    }\r\n\r\n    mouseClick(pos) {\r\n        if (this.hGame.isPhaseBlocked) return;\r\n        if (this.hGame.currentPhase !== this.hGame.PHASE_PLAYER) return;\r\n        this.clickPosQueue.push(pos);\r\n    }\r\n\r\n    update(df) {\r\n        while (df > 0 && this.clickPosQueue.length > 0) {\r\n            df--;\r\n            this.abstractController.clickGP(\r\n                this.hGame.posToGridPos(this.clickPosQueue.shift())\r\n            );\r\n        }\r\n    }\r\n}\r\n","import consts from \"/src/consts\";\r\n\r\nlet terrainTypes = consts.terrainTypes;\r\n\r\nexport default class UnitBase {\r\n    constructor(unitID, hGame, gridPos, isEnemy, imageId) {\r\n        this.unitID = unitID;\r\n\r\n        this.image = document.getElementById(imageId);\r\n        this.hGame = hGame;\r\n        this.gridPos = gridPos;\r\n        this.coordinate = hGame.gridPosToPos(gridPos);\r\n        this.imageSize = {\r\n            x: hGame.gridSize,\r\n            y: hGame.gridSize\r\n        };\r\n\r\n        this.isEnemy = isEnemy;\r\n\r\n        this.hp = 1;\r\n        this.attack = 255;\r\n        this.alive = true;\r\n\r\n        this.stamina = 0;\r\n        this.staminaMax = 1;\r\n\r\n        this.moveDist = 0;\r\n        this.moveDistMax = 2;\r\n        this.attackRange = 1;\r\n\r\n        this.pathData = null;\r\n\r\n        this.resetControlState();\r\n        this.resetProposal();\r\n    }\r\n\r\n    resetControlState() {\r\n        this.drawScale = 1;\r\n        this.isSelected = false;\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    resetProposal() {\r\n        this.hasDestProposal = false;\r\n        this.destProposalGP = null;\r\n        this.destProposalCoord = null;\r\n        this.pathToDestProposal = null;\r\n        this.pathToDestProposalCoord = null;\r\n        this.hasTargetProposal = false;\r\n        this.targetProposal = null;\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    isActive() {\r\n        if (this.stamina <= 0) return false;\r\n        return true;\r\n    }\r\n\r\n    eventNewTurn() {\r\n        // reset stamina\r\n        this.stamina = this.staminaMax;\r\n\r\n        // reset buffs & debuffs?\r\n        this.moveDist = this.moveDistMax;\r\n\r\n        // update path stuffs\r\n        this.updatePathData();\r\n    }\r\n\r\n    eventSenjoUpdated() {\r\n        this.updatePathData();\r\n    }\r\n\r\n    updatePathData() {\r\n        this.pathData = this.hGame.pathFinder.floodFill(\r\n            this,\r\n            this.gridPos,\r\n            this.moveDist\r\n        );\r\n    }\r\n\r\n    eventSelect() {\r\n        this.isSelected = true;\r\n        this.drawScale = 1.15;\r\n    }\r\n\r\n    eventDeselect() {\r\n        this.resetControlState();\r\n        this.resetProposal();\r\n    }\r\n\r\n    checkPassable(gridPos, flagIgnoreUnit = false) {\r\n        // movement types vs terrains, pass skill vs enemy etc.\r\n        if (\r\n            !flagIgnoreUnit &&\r\n            this.hGame.findOppoUnitByGridPos(this.isEnemy, gridPos) !== null\r\n        )\r\n            return false;\r\n\r\n        if (\r\n            this.hGame.stage.getTerrain(gridPos.x, gridPos.y) !==\r\n            terrainTypes.Nrm\r\n        )\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    checkMoveDestination(gridPos) {\r\n        if (\r\n            Math.abs(gridPos.x - this.gridPos.x) +\r\n                Math.abs(gridPos.y - this.gridPos.y) >\r\n            this.moveDistMax\r\n        )\r\n            return false;\r\n\r\n        if (this.hGame.pathFinder.isReachable(this.pathData, gridPos)) {\r\n            //this.acceptPath(path);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    acceptPath(path) {\r\n        this.pathToDestProposal = path;\r\n        this.pathToDestProposalCoord = [path.length];\r\n        let len = path.length;\r\n        for (let i = 0; i < len; i++) {\r\n            //alert(i + \",\" + path[i].x + \",\" + path[i].y);\r\n            this.pathToDestProposalCoord[i] = this.hGame.gridPosToPos(path[i]);\r\n        }\r\n    }\r\n\r\n    eventProposeDestination(destGP) {\r\n        this.hasDestProposal = true;\r\n        this.destProposalGP = destGP;\r\n        this.destProposalCoord = this.hGame.gridPosToPos(destGP);\r\n        this.acceptPath(\r\n            this.hGame.pathFinder.retrievePath(\r\n                this.pathData,\r\n                this.gridPos,\r\n                destGP\r\n            )\r\n        );\r\n    }\r\n\r\n    executeAction() {\r\n        this.stamina--;\r\n        this.resetProposal();\r\n        this.hGame.eventActionExecuted();\r\n    }\r\n\r\n    eventExecuteMovement() {\r\n        this.gridPos = this.destProposalGP;\r\n        this.coordinate = this.hGame.gridPosToPos(this.gridPos);\r\n        this.executeAction();\r\n    }\r\n\r\n    checkAttackTarget(unit, destProposalGP) {\r\n        if (\r\n            Math.abs(unit.gridPos.x - destProposalGP.x) +\r\n                Math.abs(unit.gridPos.y - destProposalGP.y) ===\r\n            this.attackRange\r\n        )\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    eventProposeTarget(unit) {\r\n        this.targetProposal = unit;\r\n        this.hasTargetProposal = true;\r\n    }\r\n\r\n    eventBeTargeted() {\r\n        this.isTargeted = true;\r\n    }\r\n\r\n    eventStopBeingTargeted() {\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    eventExecuteAttack(unit) {\r\n        this.gridPos = this.destProposalGP;\r\n        this.coordinate = this.hGame.gridPosToPos(this.gridPos);\r\n        this.hGame.eventBattle(this, unit);\r\n        this.executeAction();\r\n    }\r\n\r\n    eventExecuteWait() {\r\n        this.executeAction();\r\n    }\r\n\r\n    eventLoseHP(damage) {\r\n        this.hp -= damage;\r\n        if (this.hp <= 0) {\r\n            this.alive = false;\r\n            this.hGame.eventUnitDeath(this);\r\n        }\r\n    }\r\n\r\n    isInPhase() {\r\n        return (\r\n            this.isEnemy ===\r\n            (this.hGame.currentPhase === this.hGame.PHASE_ENEMY)\r\n        );\r\n    }\r\n\r\n    update(df) {}\r\n\r\n    drawUnitBG(ctx) {\r\n        if (this.isSelected || this.isTargeted) {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,85,85,0.9)\";\r\n            else ctx.fillStyle = \"rgba(136,136,238,0.9)\";\r\n        } else if (this.isActive() || !this.isInPhase()) {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,140,140,0.8)\";\r\n            else ctx.fillStyle = \"rgba(170,170,255,0.8)\";\r\n        } else {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,238,238,0.8)\";\r\n            else ctx.fillStyle = \"rgba(238,238,255,0.8)\";\r\n        }\r\n        ctx.fillRect(\r\n            this.coordinate.x - this.imageSize.x * 0.45,\r\n            this.coordinate.y - this.imageSize.y * 0.45,\r\n            this.imageSize.x * 0.9,\r\n            this.imageSize.y * 0.9\r\n        );\r\n\r\n        if (this.hasDestProposal) {\r\n            if (this.pathToDestProposal !== null) {\r\n                if (this.isEnemy) ctx.fillStyle = \"rgba(255,170,170,0.7)\";\r\n                else ctx.fillStyle = \"rgba(170,204,255,0.7)\";\r\n                let len = this.pathToDestProposal.length;\r\n                for (let i = 1; i < len; i++) {\r\n                    ctx.fillRect(\r\n                        this.pathToDestProposalCoord[i].x -\r\n                            this.imageSize.x * 0.45,\r\n                        this.pathToDestProposalCoord[i].y -\r\n                            this.imageSize.y * 0.45,\r\n                        this.imageSize.x * 0.9,\r\n                        this.imageSize.y * 0.9\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (this.isEnemy) ctx.fillStyle = \"#e88\";\r\n            else ctx.fillStyle = \"#88e\";\r\n            ctx.fillRect(\r\n                this.destProposalCoord.x - this.imageSize.x * 0.45,\r\n                this.destProposalCoord.y - this.imageSize.y * 0.45,\r\n                this.imageSize.x * 0.9,\r\n                this.imageSize.y * 0.9\r\n            );\r\n        }\r\n    }\r\n\r\n    drawUnit(ctx) {\r\n        if (this.hasDestProposal) {\r\n            ctx.drawImage(\r\n                this.image,\r\n                this.destProposalCoord.x -\r\n                    (this.imageSize.x * this.drawScale) / 2,\r\n                this.destProposalCoord.y -\r\n                    (this.imageSize.y * this.drawScale) / 2,\r\n                this.imageSize.x * this.drawScale,\r\n                this.imageSize.y * this.drawScale\r\n            );\r\n        } else {\r\n            ctx.drawImage(\r\n                this.image,\r\n                this.coordinate.x - (this.imageSize.x * this.drawScale) / 2,\r\n                this.coordinate.y - (this.imageSize.y * this.drawScale) / 2,\r\n                this.imageSize.x * this.drawScale,\r\n                this.imageSize.y * this.drawScale\r\n            );\r\n        }\r\n    }\r\n}\r\n","export default class Grid {\r\n    constructor(gridSize, maxGrid) {\r\n        this.gridSize = gridSize;\r\n        this.xMax = maxGrid.x;\r\n        this.yMax = maxGrid.y;\r\n\r\n        this.lineHalfWidth = 1;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.fillStyle = \"#03f\";\r\n        for (let x = 0; x <= this.xMax; x++) {\r\n            ctx.fillRect(\r\n                x * this.gridSize - this.lineHalfWidth,\r\n                0 - this.lineHalfWidth,\r\n                2 * this.lineHalfWidth,\r\n                this.yMax * this.gridSize + 2 * this.lineHalfWidth\r\n            );\r\n        }\r\n\r\n        for (let y = 0; y <= this.yMax; y++) {\r\n            ctx.fillRect(\r\n                0 - this.lineHalfWidth,\r\n                y * this.gridSize - this.lineHalfWidth,\r\n                this.xMax * this.gridSize + 2 * this.lineHalfWidth,\r\n                2 * this.lineHalfWidth\r\n            );\r\n        }\r\n    }\r\n}\r\n","export default class effectStartPhase {\r\n    constructor(hGame, isEnemyPhase) {\r\n        this.frame = 1;\r\n        this.maxFrame = 100;\r\n        this.isEnemyPhase = isEnemyPhase;\r\n        if (isEnemyPhase) this.image = document.getElementById(\"img_effect_EP\");\r\n        else this.image = document.getElementById(\"img_effect_PP\");\r\n        this.drawX = hGame.gameWidth;\r\n        this.drawY =\r\n            (hGame.gridSize * hGame.maxGrid.y) / 2 - this.image.height / 2;\r\n        this.hGame = hGame;\r\n    }\r\n\r\n    update(df) {\r\n        this.frame += df;\r\n        this.drawX -= 18.75 * df;\r\n        if (this.frame > this.maxFrame) this.hGame.eventEffectEnd(this);\r\n    }\r\n\r\n    draw(ctx) {\r\n        if (this.frame <= this.maxFrame)\r\n            ctx.drawImage(this.image, this.drawX, this.drawY);\r\n    }\r\n}\r\n","import AbstractController from \"/src/abstractController\";\r\nimport consts from \"/src/consts\";\r\n\r\nconst dx = [0, -1, +1, 0];\r\nconst dy = [+1, 0, 0, -1];\r\n\r\nexport default class EnemyAI {\r\n    constructor(hGame, isEnemy) {\r\n        this.hGame = hGame;\r\n        this.isEnemy = isEnemy;\r\n        if (this.isEnemy) {\r\n            this.suList = hGame.enemyUnitList;\r\n            this.ouList = hGame.playerUnitList;\r\n        } else {\r\n            this.suList = hGame.playerUnitList;\r\n            this.ouList = hGame.enemyUnitList;\r\n        }\r\n\r\n        this.absCon = new AbstractController(this.hGame, isEnemy);\r\n\r\n        this.blockFrameRemain = 0;\r\n        this.blockFramePerAttack = 18;\r\n        this.blockFramePerMove = 18;\r\n        this.blockFramePerWait = 5;\r\n    }\r\n\r\n    executeWait(unit) {\r\n        this.absCon.clickGP(unit.gridPos);\r\n        this.absCon.clickButton(consts.buttons.Wait);\r\n        this.blockFrameRemain = this.blockFramePerWait;\r\n    }\r\n\r\n    executeMove(unit, dest) {\r\n        this.absCon.clickGP(unit.gridPos);\r\n        this.absCon.clickGP(dest);\r\n        this.absCon.clickGP(dest);\r\n        this.blockFrameRemain = this.blockFramePerMove;\r\n    }\r\n\r\n    executeMoveAttack(unit, dest, target) {\r\n        //alert(unit.gridPos + \", \" + dest.gridPos + \", \" + target.gridPos);\r\n        this.absCon.clickGP(unit.gridPos);\r\n        if (dest.x === unit.gridPos.x && dest.y === unit.gridPos.y) {\r\n            this.absCon.clickGP(target.gridPos);\r\n            //alert(\"123\");\r\n            this.absCon.clickGP(target.gridPos);\r\n            //alert(\"123\");\r\n        } else {\r\n            this.absCon.clickGP(dest);\r\n            this.absCon.clickGP(target.gridPos);\r\n            this.absCon.clickGP(target.gridPos);\r\n        }\r\n        this.blockFrameRemain = this.blockFramePerAttack;\r\n    }\r\n\r\n    findOppoUnitAndAttack(suIdx) {\r\n        let su = this.suList[suIdx];\r\n\r\n        su.pathData.listPossibleDest.forEach(gp => {\r\n            for (let i = 0; i < 4; i++) {\r\n                let target = this.hGame.findOppoUnitByGridPos(this.isEnemy, {\r\n                    x: gp.x + dx[i],\r\n                    y: gp.y + dy[i]\r\n                });\r\n                if (target !== null) {\r\n                    //alert(\"found target\");\r\n                    this.executeMoveAttack(su, gp, target);\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n        return false;\r\n    }\r\n\r\n    tryGetClose(suIdx) {\r\n        let su = this.suList[suIdx];\r\n        if (su.pathData.listPossibleDest.length === 0) return false;\r\n\r\n        let minDist = 10000;\r\n        let bestGP = null;\r\n        su.pathData.listPossibleDest.forEach(gp => {\r\n            if (this.hGame.findSelfUnitByGridPos(this.isEnemy, gp) !== null)\r\n                return;\r\n            //alert(\"gp: \" + gp.x + \",\" + gp.y);\r\n            let wideSearch = this.hGame.pathFinder.floodFill(su, gp, 300, true);\r\n            this.ouList.forEach(target => {\r\n                let distTarget =\r\n                    wideSearch.dist[target.gridPos.x][target.gridPos.y];\r\n                //alert(target.unitID + \",\" + distTarget);\r\n                if (distTarget < minDist) {\r\n                    minDist = distTarget;\r\n                    bestGP = gp;\r\n                }\r\n            });\r\n        });\r\n        //alert(minDist + \", \" + bestGP);\r\n        if (bestGP !== null) {\r\n            this.executeMove(su, bestGP);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    makeOneMove() {\r\n        let i = 0,\r\n            len = this.suList.length;\r\n        for (i = 0; i < len; i++) {\r\n            if (this.suList[i].stamina > 0) {\r\n                let res = this.findOppoUnitAndAttack(i);\r\n                if (res === false) res = this.tryGetClose(i);\r\n                if (res === false) this.executeWait(this.suList[i]);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    update(df) {\r\n        this.blockFrameRemain -= df;\r\n        if (this.blockFrameRemain <= 0) {\r\n            this.makeOneMove();\r\n        }\r\n    }\r\n}\r\n","const dx = [0, -1, +1, 0];\r\nconst dy = [+1, 0, 0, -1];\r\nconst MAX_DIST = 100000;\r\n\r\nexport default class PathFinder {\r\n    constructor(hGame) {\r\n        this.hGame = hGame;\r\n        this.maxGrid = hGame.maxGrid;\r\n        this.eList = hGame.enemyUnitList;\r\n        this.pList = hGame.playerUnitList;\r\n        this.hStage = hGame.stage;\r\n\r\n        this.visited = null;\r\n        this.path = null;\r\n    }\r\n\r\n    /* \r\n        Main service of PathFinder.\r\n        return a pathData = {prev, dist, listPossibleDest}.\r\n        prev[x][y] := gp of parent node in the path tree.\r\n        dist[x][y] := dist from startGP.\r\n        listPossibleDest := [] of reachable positions.\r\n    */\r\n    floodFill(unit, startGP, searchRange, flagIgnoreUnit = false) {\r\n        let prev = [this.maxGrid.x + 1];\r\n        let dist = [this.maxGrid.x + 1];\r\n        for (let i = 1; i <= this.maxGrid.x; i++) {\r\n            prev[i] = [this.maxGrid.y + 1];\r\n            dist[i] = [this.maxGrid.y + 1];\r\n            for (let j = 1; j <= this.maxGrid.y; j++) {\r\n                dist[i][j] = MAX_DIST;\r\n                prev[i][j] = null;\r\n            }\r\n        }\r\n\r\n        let queue = [];\r\n        let head = 1,\r\n            tail = 0;\r\n        queue[head] = startGP;\r\n        prev[startGP.x][startGP.y] = startGP;\r\n        dist[startGP.x][startGP.y] = 0;\r\n        let listPossibleDest = [];\r\n        listPossibleDest.push(startGP);\r\n\r\n        while (head > tail) {\r\n            tail++;\r\n            if (dist[queue[tail].x][queue[tail].y] >= searchRange) continue;\r\n            for (let i = 0; i < 4; i++) {\r\n                let xNew = queue[tail].x + dx[i];\r\n                let yNew = queue[tail].y + dy[i];\r\n                if (\r\n                    xNew >= 1 &&\r\n                    xNew <= this.maxGrid.x &&\r\n                    yNew >= 1 &&\r\n                    yNew <= this.maxGrid.y &&\r\n                    dist[xNew][yNew] === MAX_DIST\r\n                ) {\r\n                    let gpNew = { x: xNew, y: yNew };\r\n                    if (unit.checkPassable(gpNew, flagIgnoreUnit)) {\r\n                        head++;\r\n                        queue[head] = gpNew;\r\n                        dist[xNew][yNew] =\r\n                            dist[queue[tail].x][queue[tail].y] + 1;\r\n                        prev[xNew][yNew] = queue[tail];\r\n                        listPossibleDest.push(gpNew);\r\n                    }\r\n                    //alert(xNew + \",\" + yNew + \",\" + dist[xNew][yNew]);\r\n                }\r\n            }\r\n        }\r\n        return { prev: prev, dist: dist, listPossibleDest: listPossibleDest };\r\n    }\r\n\r\n    /*\r\n        Minor service. Tells from pathData whether goalGP is reachable.\r\n    */\r\n    isReachable(pathData, goalGP) {\r\n        return pathData.dist[goalGP.x][goalGP.y] !== MAX_DIST;\r\n    }\r\n\r\n    /*\r\n        Main service. Extract the path starting from startGP to goalGP\r\n        from pathData. \r\n        path[0] should always be startGP if done correctly.\r\n        goalGP is NOT included in the path.\r\n    */\r\n    retrievePath(pathData, startGP, goalGP) {\r\n        let prev = pathData.prev;\r\n        if (prev[goalGP.x][goalGP.y] !== null) {\r\n            let x = goalGP.x,\r\n                y = goalGP.y;\r\n            let dist = 0;\r\n            //alert(x + \",\" + y);\r\n            while (x !== startGP.x || y !== startGP.y) {\r\n                dist++;\r\n                let xNew = prev[x][y].x;\r\n                y = prev[x][y].y;\r\n                x = xNew;\r\n                //alert(x + \",\" + y);\r\n            }\r\n            let path = [dist];\r\n            x = goalGP.x;\r\n            y = goalGP.y;\r\n            for (let i = 0; i < dist; i++) {\r\n                path[dist - i - 1] = prev[x][y];\r\n                let xNew = prev[x][y].x;\r\n                y = prev[x][y].y;\r\n                x = xNew;\r\n            }\r\n            return path;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPath(unit, startGP, goalGP) {\r\n        let pathData = this.floodFill(unit, startGP, unit.moveDist);\r\n        //alert(startGP.x + \",\" + startGP.y + \",\" + goalGP.x + \",\" + goalGP.y);\r\n        return this.retrievePath(pathData, startGP, goalGP);\r\n    }\r\n}\r\n","import consts from \"/src/consts\";\r\nlet T = consts.terrainTypes;\r\n\r\nexport default class Stage {\r\n    constructor(maxGrid, terrainMap, unitList) {\r\n        this.maxGrid = maxGrid;\r\n        this.terrainMap = terrainMap; // NOTE: use it as [y-1][x-1] !! or getTerrain(x,y)\r\n        this.unitList = unitList;\r\n\r\n        this.imageCache = [];\r\n        this.hGame = null; // should not be initialised in constructor because it's called by stage scripts rather than game\r\n    }\r\n\r\n    initStage(hGame) {\r\n        this.hGame = hGame;\r\n        // push stuffs into game by calling events\r\n        this.unitList.forEach(unit => {\r\n            if (unit.appearTurn === 0)\r\n                hGame.eventPlaceUnit(unit.gridPos, unit.isEnemy, unit.image);\r\n        });\r\n\r\n        this.imageCache[T.Nrm] = document.getElementById(\"img_terrain_grass\");\r\n        this.imageCache[T.Mnt] = document.getElementById(\"img_terrain_yama\");\r\n        this.imageCache[T.Wtr] = document.getElementById(\"img_terrain_kawa\");\r\n    }\r\n\r\n    endTurn(hGame) {\r\n        this.unitList.forEach(unit => {\r\n            if (\r\n                unit.appearTurn === hGame.turn &&\r\n                unit.isEnemy === (hGame.currentPhase === hGame.PHASE_ENEMY)\r\n            )\r\n                hGame.eventPlaceUnit(unit.gridPos, unit.isEnemy, unit.image);\r\n        });\r\n    }\r\n\r\n    getTerrain(x, y) {\r\n        return this.terrainMap[y - 1][x - 1];\r\n    }\r\n\r\n    update(df) {}\r\n\r\n    draw(ctx) {\r\n        for (let i = 1; i <= this.maxGrid.x; i++) {\r\n            for (let j = 1; j <= this.maxGrid.y; j++) {\r\n                let pos = this.hGame.gridPosToPos({ x: i, y: j });\r\n                //alert(i + \",\" + j + \", \" + [this.terrainMap[j][i]]);\r\n                ctx.drawImage(\r\n                    this.imageCache[this.getTerrain(i, j)],\r\n                    pos.x - this.hGame.gridSize / 2,\r\n                    pos.y - this.hGame.gridSize / 2,\r\n                    this.hGame.gridSize,\r\n                    this.hGame.gridSize\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n","import Stage from \"/src/stage\";\r\nimport consts from \"/src/consts\";\r\n\r\nlet T = consts.terrainTypes;\r\n\r\nlet maxGrid = { x: 6, y: 8 };\r\nlet terrainMap = [\r\n    [T.Nrm, T.Mnt, T.Mnt, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Wtr],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Mnt, T.Mnt, T.Nrm]\r\n];\r\n\r\nlet unitList = [\r\n    {\r\n        gridPos: { x: 2, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 4, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 5, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n\r\n    {\r\n        gridPos: { x: 1, y: 1 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 2 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 4, y: 1 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 4 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 5, y: 2 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    }\r\n];\r\n\r\nexport default new Stage(maxGrid, terrainMap, unitList);\r\n","import UnitBase from \"/src/unitBase\";\r\nimport Grid from \"/src/grid\";\r\nimport EffectStartPhase from \"/src/effects/effectStartPhase\";\r\nimport EnemyAI from \"/src/enemyAI\";\r\nimport PathFinder from \"/src/pathFinder\";\r\nimport Stage01 from \"/src/stages/stage01\";\r\nimport consts from \"/src/consts\";\r\n\r\nexport default class Game {\r\n    constructor(gameWidth, gameHeight, canvas) {\r\n        this.PHASE_NONE = 0;\r\n        this.PHASE_PLAYER = 1;\r\n        this.PHASE_ENEMY = 2;\r\n\r\n        this.gameWidth = gameWidth;\r\n        this.gameHeight = gameHeight;\r\n        this.hCanvas = canvas;\r\n\r\n        this.maxGrid = { x: 6, y: 8 };\r\n\r\n        this.gridSize = gameWidth / this.maxGrid.x;\r\n        this.grid = new Grid(this.gridSize, this.maxGrid);\r\n\r\n        this.playerUnitList = [];\r\n        this.enemyUnitList = [];\r\n        this.unitID = 0;\r\n\r\n        this.effectList = [];\r\n\r\n        this.totalActiveStamina = 0;\r\n        this.currentPhase = this.PHASE_NONE;\r\n        this.isPhaseBlocked = false;\r\n        this.framesBeforeChangePhase = 0;\r\n\r\n        this.turn = 0;\r\n        this.stage = null;\r\n        this.enemyAI = new EnemyAI(this, true);\r\n        this.pathFinder = new PathFinder(this);\r\n\r\n        this.gameResult = consts.gameResult.None;\r\n    }\r\n\r\n    bindPlayerInputHandler(inputHandler) {\r\n        this.playerInputHandler = inputHandler;\r\n    }\r\n\r\n    eventPlaceUnit(gridPos, isEnemy, image) {\r\n        this.unitID++;\r\n        if (isEnemy)\r\n            this.enemyUnitList.push(\r\n                new UnitBase(this.unitID, this, gridPos, isEnemy, image)\r\n            );\r\n        else\r\n            this.playerUnitList.push(\r\n                new UnitBase(this.unitID, this, gridPos, isEnemy, image)\r\n            );\r\n    }\r\n\r\n    start() {\r\n        this.stage = Stage01;\r\n        this.stage.initStage(this);\r\n\r\n        this.playerPhase();\r\n    }\r\n\r\n    eventActionExecuted() {\r\n        this.totalActiveStamina--;\r\n        if (this.totalActiveStamina <= 0) {\r\n            this.endPhase();\r\n        }\r\n        if (this.currentPhase === this.PHASE_PLAYER) {\r\n            this.playerUnitList.forEach(object => object.eventSenjoUpdated());\r\n        } else if (this.currentPhase === this.PHASE_ENEMY) {\r\n            this.enemyUnitList.forEach(object => object.eventSenjoUpdated());\r\n        }\r\n    }\r\n\r\n    playerPhase() {\r\n        //alert(\"Player Phase\");\r\n        this.turn++;\r\n        this.currentPhase = this.PHASE_PLAYER;\r\n        this.totalActiveStamina = 0;\r\n        this.playerUnitList.forEach(object => {\r\n            object.eventNewTurn();\r\n            this.totalActiveStamina += object.stamina;\r\n        });\r\n    }\r\n\r\n    enemyPhase() {\r\n        //alert(\"Enemy Phase\");\r\n        this.currentPhase = this.PHASE_ENEMY;\r\n        this.totalActiveStamina = 0;\r\n        this.enemyUnitList.forEach(object => {\r\n            object.eventNewTurn();\r\n            this.totalActiveStamina += object.stamina;\r\n        });\r\n        //this.endPhase();\r\n    }\r\n\r\n    endPhase() {\r\n        this.stage.endTurn(this);\r\n        this.framesBeforeChangePhase = 80;\r\n        this.isPhaseBlocked = true;\r\n        if (this.currentPhase === this.PHASE_PLAYER) {\r\n            this.effectList.push(new EffectStartPhase(this, true));\r\n        } else {\r\n            this.effectList.push(new EffectStartPhase(this, false));\r\n        }\r\n    }\r\n\r\n    procChangePhase(df) {\r\n        this.framesBeforeChangePhase -= df;\r\n        if (this.framesBeforeChangePhase <= 0) {\r\n            this.isPhaseBlocked = false;\r\n            if (this.currentPhase === this.PHASE_PLAYER) {\r\n                this.enemyPhase();\r\n            } else if (this.currentPhase === this.PHASE_ENEMY) {\r\n                this.playerPhase();\r\n            }\r\n        }\r\n    }\r\n\r\n    findUnitInListByGridPos(unitList, gridPos) {\r\n        let len = unitList.length;\r\n        for (let i = 0; i < len; i++) {\r\n            if (\r\n                unitList[i].gridPos.x === gridPos.x &&\r\n                unitList[i].gridPos.y === gridPos.y\r\n            ) {\r\n                return unitList[i]; // only one unit should be triggered\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPlayerUnitByGridPos(gridPos) {\r\n        //alert(gridPos.x + \", \" + gridPos.y);\r\n        return this.findUnitInListByGridPos(this.playerUnitList, gridPos);\r\n    }\r\n\r\n    findEnemyUnitByGridPos(gridPos) {\r\n        return this.findUnitInListByGridPos(this.enemyUnitList, gridPos);\r\n    }\r\n\r\n    findSelfUnitByGridPos(isEnemy, gridPos) {\r\n        if (isEnemy) return this.findEnemyUnitByGridPos(gridPos);\r\n        else return this.findPlayerUnitByGridPos(gridPos);\r\n    }\r\n\r\n    findOppoUnitByGridPos(isEnemy, gridPos) {\r\n        if (isEnemy) return this.findPlayerUnitByGridPos(gridPos);\r\n        else return this.findEnemyUnitByGridPos(gridPos);\r\n    }\r\n\r\n    findUnitByGridPos(gridPos) {\r\n        let unit = this.findPlayerUnitByGridPos(gridPos);\r\n        if (unit !== null) return unit;\r\n        unit = this.findEnemyUnitByGridPos(gridPos);\r\n        if (unit !== null) return unit;\r\n        return null;\r\n    }\r\n\r\n    mouseClick(pos) {\r\n        // do nothing\r\n    }\r\n\r\n    eventBattle(attacker, target) {\r\n        target.eventLoseHP(attacker.attack);\r\n    }\r\n\r\n    eventUnitDeath(unit) {\r\n        if (unit.isEnemy) removeObjectFromList(unit, this.enemyUnitList);\r\n        else removeObjectFromList(unit, this.playerUnitList);\r\n\r\n        if (this.enemyUnitList.length <= 0)\r\n            this.gameResult = consts.gameResult.Win;\r\n        else if (this.playerUnitList.length <= 0) {\r\n            this.gameResult = consts.gameResult.Lose;\r\n        }\r\n    }\r\n\r\n    eventEffectEnd(effect) {\r\n        removeObjectFromList(effect, this.effectList);\r\n    }\r\n\r\n    update(df) {\r\n        if (this.framesBeforeChangePhase > 0) this.procChangePhase(df);\r\n        if (this.currentPhase === this.PHASE_ENEMY) this.enemyAI.update(df);\r\n        this.playerInputHandler.update(df);\r\n\r\n        this.playerUnitList.forEach(object => object.update(df));\r\n        this.enemyUnitList.forEach(object => object.update(df));\r\n        this.effectList.forEach(object => object.update(df));\r\n    }\r\n\r\n    draw(ctx) {\r\n        this.stage.draw(ctx);\r\n        this.grid.draw(ctx);\r\n        this.playerUnitList.forEach(object => object.drawUnitBG(ctx));\r\n        this.enemyUnitList.forEach(object => object.drawUnitBG(ctx));\r\n        this.playerUnitList.forEach(object => object.drawUnit(ctx));\r\n        this.enemyUnitList.forEach(object => object.drawUnit(ctx));\r\n\r\n        this.effectList.forEach(object => object.draw(ctx));\r\n\r\n        if (this.gameResult !== consts.gameResult.None) {\r\n            //alert(\"oxoxoxox\");\r\n        }\r\n    }\r\n\r\n    gridPosToPos(gridPos) {\r\n        return {\r\n            x: gridPos.x * this.gridSize - this.gridSize / 2,\r\n            y: gridPos.y * this.gridSize - this.gridSize / 2\r\n        };\r\n    }\r\n\r\n    posToGridPos(pos) {\r\n        return {\r\n            x: Math.floor(pos.x / this.gridSize) + 1,\r\n            y: Math.floor(pos.y / this.gridSize) + 1\r\n        };\r\n    }\r\n}\r\n\r\nfunction removeObjectFromList(object, list) {\r\n    let len = list.length,\r\n        i = 0;\r\n    for (i = 0; i < len; i++) {\r\n        if (list[i] === object) break;\r\n    }\r\n    list.splice(i, 1);\r\n}\r\n","import InputHandler from \"/src/inputHandler\";\nimport Game from \"/src/game\";\nimport consts from \"/src/consts\";\n\nlet canvas = document.getElementById(\"gameScreen\");\nlet ctx = canvas.getContext(\"2d\");\n\nconst GAME_WIDTH = 360;\nconst GAME_HEIGHT = 640;\n\n//let paddle = new Paddle(GAME_WIDTH, GAME_HEIGHT);\n\nlet game = new Game(GAME_WIDTH, GAME_HEIGHT, canvas);\nlet playerInputHandler = new InputHandler(game);\ngame.bindPlayerInputHandler(playerInputHandler);\n\ngame.start();\n\nlet lastTime = 0;\nfunction gameLoop(timestamp) {\n    let dt = timestamp - lastTime;\n    lastTime = timestamp;\n    let df = dt / 16; // assume 16 ms per frame\n\n    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    game.update(df);\n    game.draw(ctx);\n\n    if (game.gameResult === consts.gameResult.None) {\n        requestAnimationFrame(gameLoop);\n    } else if (game.gameResult === consts.gameResult.Win) alert(\"You win!\");\n    else if (game.gameResult === consts.gameResult.Lose) alert(\"GAME OVER\");\n}\n\nrequestAnimationFrame(gameLoop);\n"]}
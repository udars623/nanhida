{"version":3,"sources":["src/consts.js","src/abstractController.js","src/inputHandler.js","src/unitBase.js","src/grid.js","src/effects/effectStartPhase.js","src/enemyAI.js","src/pathFinder.js","src/stage.js","src/stages/stage00.js","src/stages/stage01.js","src/button.js","src/game.js","src/mapSelecter.js","src/index.js"],"names":["consts","terrainTypes","Nrm","Mnt","Wtr","Wll","buttons","TurnEnd","Wait","gameResult","None","Win","Lose","GameEnded","CTRL_STATE_NONE","CTRL_STATE_SELECTED","CTRL_STATE_DEST_CHOSEN","CTRL_STATE_TARGET_CHOSEN","AbstractController","game","isEnemy","hGame","ctrlState","currentButtonID","currentUnit","currentDest","currentTarget","eventDeselect","eventStopBeingTargeted","gp","eventProposeDestination","unit","eventProposeTarget","eventBeTargeted","buttonID","stateDeselect","eventButtonTurnEnd","stateClearButton","eventExecuteWait","x","maxGrid","y","findSelfUnitByGridPos","isActive","eventSelect","findOppoUnitByGridPos","findUnitByGridPos","checkMoveDestination","stateConfirmDestination","checkAttackTarget","gridPos","localAlert","stateConfirmTarget","eventExecuteMovement","eventExecuteAttack","str","InputHandler","hCanvas","abstractController","clickPosQueue","isMobile","test","navigator","userAgent","isApple","touchEvent","addEventListener","event","mouseClick","getMousePosWithinCanvas","preventDefault","undefined","touches","rect","getBoundingClientRect","clientX","left","right","width","clientY","top","bottom","height","pos","isPhaseBlocked","currentPhase","PHASE_PLAYER","push","df","length","shift","gameWidth","gameHeight","clickGP","posToGridPos","clickButton","findButton","UnitBase","unitID","imageId","image","document","getElementById","coordinate","gridPosToPos","imageSize","gridSize","hp","attack","alive","stamina","staminaMax","moveDistMax","attackRange","moveDist","pathData","resetControlState","resetProposal","drawScale","isSelected","isTargeted","hasDestProposal","destProposalGP","destProposalCoord","pathToDestProposal","pathToDestProposalCoord","hasTargetProposal","targetProposal","updatePathData","pathFinder","floodFill","stage","getTerrain","Math","abs","isReachable","path","len","i","destGP","acceptPath","retrievePath","eventActionExecuted","executeAction","eventBattle","damage","eventUnitDeath","PHASE_ENEMY","ctx","fillStyle","listAttackable","forEach","fillRect","listPossibleDest","isInPhase","drawImage","Grid","xMax","yMax","lineHalfWidth","effectStartPhase","isEnemyPhase","frame","maxFrame","drawX","drawY","eventEffectEnd","d1","d2","MAX_DIST","EnemyAI","suList","enemyUnitList","ouList","playerUnitList","absCon","blockFrameRemain","blockFramePerAttack","blockFramePerMove","blockFramePerWait","dest","target","su","dAttacks","minDist","bestGP","dgp","checkIfGpInMaxGrid","dist","suIdx","flagDone","executeMoveAttack","findBestAttackPosition","wideSearch","distTarget","executeMove","res","findOppoUnitAndAttack","tryGetClose","executeWait","makeOneMove","dx","dy","PathFinder","eList","pList","hStage","visited","startGP","searchRange","flagIgnoreUnit","prev","attackable","j","queue","head","tail","addAttackable","xNew","yNew","gpNew","checkPassable","goalGP","xOrigin","yOrigin","T","Stage","terrainMap","unitList","imageCache","appearTurn","eventPlaceUnit","turn","createStage","BUTTON_OFFSET_X","Button","imgString","id","drawGP","img","drawScaleMax","min","Game","canvas","PHASE_NONE","grid","buttonList","makeButtons","resetGameState","effectList","totalActiveStamina","framesBeforeChangePhase","enemyAI","inputHandler","playerInputHandler","stageIdxStr","initStage","playerPhase","requirePathUpdate","object","eventRequirePathUpdate","endPhase","eventNewTurn","endTurn","EffectStartPhase","enemyPhase","findUnitInListByGridPos","findEnemyUnitByGridPos","findPlayerUnitByGridPos","result","button","checkClick","eventClick","attacker","eventLoseHP","removeObjectFromList","effect","update","procChangePhase","alert","draw","drawThreat","drawUnitBG","drawUnit","floor","list","splice","MapSelecter","innerHTML","e","options","selectedIndex","value","start","getContext","GAME_WIDTH","GAME_HEIGHT","DRAW_WIDTH","DRAW_HEIGHT","bindPlayerInputHandler","mapSelecter","lastTime","gameLoop","timestamp","dt","clearRect","requestAnimationFrame","scriptCollapsibles","collapsibles","getElementsByClassName","classList","toggle","content","nextElementSibling","style","display"],"mappings":"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","file":"src.3f2800f2.js","sourceRoot":"..","sourcesContent":["const consts = {\r\n    terrainTypes: {\r\n        Nrm: 0, // normal\r\n        Mnt: 1, // mountain\r\n        Wtr: 2, // water\r\n        Wll: 3 // wall\r\n    },\r\n    buttons: {\r\n        TurnEnd: 0,\r\n        Wait: 1\r\n    },\r\n    gameResult: {\r\n        None: 0,\r\n        Win: 1,\r\n        Lose: 2,\r\n\t\tGameEnded: 3\r\n    }\r\n};\r\nexport default consts;\r\n","import consts from \"/src/consts\";\r\n\r\nconst CTRL_STATE_NONE = 0; // no player unit selected (can have enemy unit selected)\r\nconst CTRL_STATE_SELECTED = 1; // player unit selected\r\nconst CTRL_STATE_DEST_CHOSEN = 2; // move pos selected\r\nconst CTRL_STATE_TARGET_CHOSEN = 3; // attack target selected, one more click to execute\r\n//const CTRL_STATE_BUTTON = 4; // clicked some button.\r\n\r\n\r\n// this stuff will be used by both player and AI\r\n// AI use it by faking clicks. It'll be a longer seq of codes for AI scripts but it will make sure consistency.\r\n// under such framework, AI should never call unit's event methods.\r\n\r\n// The main reason we have this stuff is because I wrongly \r\n// made it possible for controllers to change unit states directly.\r\n// The more proper way to do this is that the controller tells the game\r\n// and then the game changes unit states.\r\n\r\n// but yeah now I think this stuff might be good for making replays consistent.\r\n\r\nexport default class AbstractController {\r\n    constructor(game, isEnemy) {\r\n        this.hGame = game;\r\n        this.isEnemy = isEnemy;\r\n        this.ctrlState = CTRL_STATE_NONE;\r\n\t\tthis.currentButtonID = null;\r\n        this.currentUnit = null;\r\n        this.currentDest = null;\r\n        this.currentTarget = null;\r\n    }\r\n\r\n    stateDeselect() {\r\n        this.currentUnit.eventDeselect();\r\n        this.currentUnit = null;\r\n\t\tif (this.currentTarget !== null) {\r\n\t\t\tthis.currentTarget.eventStopBeingTargeted();\r\n\t\t\tthis.currentTarget = null;\r\n\t\t}\r\n        this.ctrlState = CTRL_STATE_NONE;\r\n    }\r\n\r\n    stateConfirmDestination(gp) {\r\n        this.currentDest = gp;\r\n        this.ctrlState = CTRL_STATE_DEST_CHOSEN;\r\n        this.currentUnit.eventProposeDestination(gp);\r\n    }\r\n\t\r\n\tstateClearButton() {\r\n\t\tthis.currentButtonID = null;\r\n\t}\r\n\r\n    stateConfirmTarget(unit) {\r\n        this.ctrlState = CTRL_STATE_TARGET_CHOSEN;\r\n        this.currentTarget = unit;\r\n        this.currentUnit.eventProposeTarget(unit);\r\n        unit.eventBeTargeted(); // this doesn't seem right here, should be in Game or at least another class\r\n    }\r\n\r\n    clickButton(buttonID) {\r\n        if (buttonID === consts.buttons.TurnEnd) {\r\n            if (this.ctrlState === CTRL_STATE_NONE \r\n\t\t\t\t|| this.ctrlState === CTRL_STATE_SELECTED) \r\n\t\t\t{\r\n\t\t\t\tif (this.currentButtonID === null) {\r\n\t\t\t\t\t// first time clicked\r\n\t\t\t\t\tthis.currentButtonID = buttonID;\r\n\t\t\t\t\tif (this.currentUnit !== null) this.stateDeselect();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (this.currentButtonID === consts.buttons.TurnEnd) {\r\n\t\t\t\t\t// second time: execute\r\n\t\t\t\t\tthis.hGame.eventButtonTurnEnd();\r\n\t\t\t\t\tthis.stateClearButton();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// wrong button\r\n\t\t\t\t\tthis.stateClearButton();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.stateClearButton();\r\n\t\t\t}\r\n        } else if (buttonID === consts.buttons.Wait) {\r\n            if (this.ctrlState === CTRL_STATE_SELECTED) {\r\n\t\t\t\tif (this.currentButtonID === null) {\r\n\t\t\t\t\t// first time clicked\r\n\t\t\t\t\tthis.currentButtonID = buttonID;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (this.currentButtonID === consts.buttons.Wait) {\r\n\t\t\t\t\t// second time: execute\r\n\t\t\t\t\tthis.currentUnit.eventExecuteWait();\r\n\t\t\t\t\tthis.stateDeselect();\r\n\t\t\t\t\tthis.stateClearButton();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// wrong button\r\n\t\t\t\t\tthis.stateClearButton();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.stateClearButton();\r\n\t\t\t}\r\n        }\r\n        return false;\r\n    }\r\n\r\n    clickGP(gp) {\r\n        if (\r\n            gp.x < 1 ||\r\n            gp.x > this.hGame.maxGrid.x ||\r\n            gp.y < 1 ||\r\n            gp.y > this.hGame.maxGrid.y\r\n        ) {\r\n            //localAlert(\"the selected position is out of bound\");\r\n            return false;\r\n        }\r\n\t\t\r\n\t\tthis.stateClearButton();\r\n\r\n        if (this.ctrlState === CTRL_STATE_NONE) {\r\n            // no player unit selected before, check which unit to select now\r\n            if (this.currentUnit !== null) {\r\n                this.currentUnit.eventDeselect();\r\n                this.currentUnit = null;\r\n            }\r\n            let unit = this.hGame.findSelfUnitByGridPos(this.isEnemy, gp);\r\n            if (unit !== null) {\r\n                if (unit.isActive()) this.ctrlState = CTRL_STATE_SELECTED;\r\n                this.currentUnit = unit;\r\n                unit.eventSelect();\r\n            } else {\r\n                unit = this.hGame.findOppoUnitByGridPos(this.isEnemy, gp);\r\n                if (unit !== null) {\r\n                    this.currentUnit = unit;\r\n                    unit.eventSelect();\r\n                }\r\n            }\r\n            if (unit === null) {\r\n                //localAlert(\"No unit found\");\r\n                this.ctrlState = CTRL_STATE_NONE;\r\n                return false;\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_SELECTED) {\r\n            // player unit selected, check where to move now\r\n            let unit = this.hGame.findUnitByGridPos(gp);\r\n            if (unit === null && this.currentUnit.checkMoveDestination(gp)) {\r\n                this.stateConfirmDestination(gp);\r\n                return true;\r\n            } else {\r\n                if (\r\n                    unit !== null &&\r\n                    unit.isEnemy !== this.isEnemy &&\r\n                    this.currentUnit.checkAttackTarget(\r\n                        unit,\r\n                        this.currentUnit.gridPos\r\n                    )\r\n                ) {\r\n                    localAlert(\r\n                        \"selected an eligible target during dest proposition\"\r\n                    );\r\n                    this.stateConfirmDestination(this.currentUnit.gridPos);\r\n                    this.stateConfirmTarget(unit);\r\n                    return true;\r\n                } else {\r\n                    localAlert(\"invalid destination\");\r\n                    this.stateDeselect();\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_DEST_CHOSEN) {\r\n            // destination chosen, execute movement or find attack target.\r\n            let unit = this.hGame.findUnitByGridPos(gp);\r\n            if (\r\n                unit === null &&\r\n                gp.x === this.currentDest.x &&\r\n                gp.y === this.currentDest.y\r\n            ) {\r\n                // execute movement\r\n                this.currentUnit.eventExecuteMovement(gp);\r\n                this.stateDeselect();\r\n                return true;\r\n            } else {\r\n                if (\r\n                    unit !== null &&\r\n                    unit.isEnemy !== this.isEnemy &&\r\n                    this.currentUnit.checkAttackTarget(unit, this.currentDest)\r\n                ) {\r\n                    // target confirmed\r\n                    this.stateConfirmTarget(unit);\r\n                    return true;\r\n                } else {\r\n                    // invalid target\r\n                    this.stateDeselect();\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (this.ctrlState === CTRL_STATE_TARGET_CHOSEN) {\r\n            if (\r\n                gp.x === this.currentTarget.gridPos.x &&\r\n                gp.y === this.currentTarget.gridPos.y\r\n            ) {\r\n                // execute attack\r\n                this.currentUnit.eventExecuteAttack(this.currentTarget);\r\n                //this.currentTarget.eventStopBeingTargeted();\r\n                this.stateDeselect();\r\n                return true;\r\n            } else {\r\n                // not the same gridpos as proposed target, forfeit\r\n                //this.currentTarget.eventStopBeingTargeted();\r\n                this.stateDeselect();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        localAlert(\r\n            \"this alert should not happen due to returns. x: \" +\r\n                gp.x +\r\n                \", y: \" +\r\n                gp.y +\r\n                \";  ctrl state: \" +\r\n                this.ctrlState\r\n        );\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction localAlert(str) {\r\n    // not sure if it really localise or is still global...\r\n    //alert(str);\r\n}\r\n","import AbstractController from \"./abstractController\";\r\n\r\nexport default class InputHandler {\r\n    constructor(game) {\r\n        this.hGame = game;\r\n        this.hCanvas = game.hCanvas;\r\n        this.abstractController = new AbstractController(game, false);\r\n        this.clickPosQueue = [];\r\n\r\n        // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\r\n        this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\r\n        this.isApple = /iPhone|iPad|iPod/i.test(navigator.userAgent);\r\n        let touchEvent = this.isMobile ? \"touchstart\" : \"click\";\r\n\r\n        this.hCanvas.addEventListener(touchEvent, event => {\r\n            this.mouseClick(this.getMousePosWithinCanvas(event));\r\n            if (this.isMobile) event.preventDefault();\r\n        });\r\n\r\n        if (this.isMobile) {\r\n            this.hCanvas.addEventListener(\"touchmove\", event => {\r\n                event.preventDefault();\r\n            });\r\n            this.hCanvas.addEventListener(\"touchend\", event => {\r\n                event.preventDefault();\r\n            });\r\n        }\r\n    }\r\n\r\n    getMousePosWithinCanvas(event) {\r\n        // https://stackoverflow.com/questions/9585487/cant-get-coordinates-of-touchevents-in-javascript-on-android-devices\r\n        // holy crap so if it's a TouchEvent then it can capture more than one touch and store them into an array\r\n        // ah yeah so that's probably how multi-touch works. make sense\r\n        if (event.touches !== undefined) event = event.touches[0];\r\n\r\n        // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas\r\n        let rect = this.hCanvas.getBoundingClientRect();\r\n        return {\r\n            x:\r\n                ((event.clientX - rect.left) / (rect.right - rect.left)) *\r\n                this.hCanvas.width,\r\n            y:\r\n                ((event.clientY - rect.top) / (rect.bottom - rect.top)) *\r\n                this.hCanvas.height\r\n        };\r\n    }\r\n\r\n    mouseClick(pos) {\r\n        if (this.hGame.isPhaseBlocked) return;\r\n        if (this.hGame.currentPhase !== this.hGame.PHASE_PLAYER) return;\r\n        this.clickPosQueue.push(pos);\r\n    }\r\n\r\n    update(df) {\r\n        while (df > 0 && this.clickPosQueue.length > 0) {\r\n            df--;\r\n\t\t\tlet pos = this.clickPosQueue.shift();\r\n\t\t\tif (pos.x <= this.hGame.gameWidth && pos.y <= this.hGame.gameHeight) {\r\n\t\t\t\tthis.abstractController.clickGP(this.hGame.posToGridPos(pos));\r\n\t\t\t} else {\r\n\t\t\t\tthis.abstractController.clickButton(this.hGame.findButton(pos));\r\n\t\t\t}\r\n        }\r\n    }\r\n}\r\n","import consts from \"/src/consts\";\r\n\r\nlet terrainTypes = consts.terrainTypes;\r\n\r\nexport default class UnitBase {\r\n    constructor(unitID, hGame, gridPos, isEnemy, imageId) {\r\n        this.unitID = unitID;\r\n\r\n        this.image = document.getElementById(imageId);\r\n        this.hGame = hGame;\r\n        this.gridPos = gridPos;\r\n        this.coordinate = hGame.gridPosToPos(gridPos);\r\n        this.imageSize = {\r\n            x: hGame.gridSize,\r\n            y: hGame.gridSize\r\n        };\r\n\r\n        this.isEnemy = isEnemy;\r\n\r\n        this.hp = 1;\r\n        this.attack = 255;\r\n        this.alive = true;\r\n\r\n        this.stamina = 0;\r\n        this.staminaMax = 1;\r\n\r\n        this.moveDistMax = 2;\r\n        this.attackRange = 1;\r\n\t\t\r\n\t\tthis.moveDist = this.moveDistMax;\r\n\r\n        this.pathData = null;\r\n\r\n        this.resetControlState();\r\n        this.resetProposal();\r\n    }\r\n\r\n    resetControlState() {\r\n        this.drawScale = 1;\r\n        this.isSelected = false;\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    resetProposal() {\r\n        this.hasDestProposal = false;\r\n        this.destProposalGP = null;\r\n        this.destProposalCoord = null;\r\n        this.pathToDestProposal = null;\r\n        this.pathToDestProposalCoord = null;\r\n        this.hasTargetProposal = false;\r\n        this.targetProposal = null;\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    isActive() {\r\n        if (this.stamina <= 0) return false;\r\n        return true;\r\n    }\r\n\r\n    eventNewTurn() {\r\n        // reset stamina\r\n        this.stamina = this.staminaMax;\r\n\r\n        // reset buffs & debuffs?\r\n        this.moveDist = this.moveDistMax;\r\n    }\r\n\r\n\t// super important stuff\r\n    eventRequirePathUpdate() {\r\n        this.updatePathData();\r\n    }\r\n\r\n    updatePathData() {\r\n        this.pathData = this.hGame.pathFinder.floodFill(\r\n            this,\r\n            this.gridPos,\r\n            this.moveDist\r\n        );\r\n    }\r\n\r\n    eventSelect() {\r\n        this.isSelected = true;\r\n        this.drawScale = 1.15;\r\n    }\r\n\r\n    eventDeselect() {\r\n        this.resetControlState();\r\n        this.resetProposal();\r\n    }\r\n\r\n    checkPassable(gridPos, flagIgnoreUnit = false) {\r\n        // movement types vs terrains, pass skill vs enemy etc.\r\n        if (\r\n            !flagIgnoreUnit &&\r\n            this.hGame.findOppoUnitByGridPos(this.isEnemy, gridPos) !== null\r\n        )\r\n            return false;\r\n\r\n        if (\r\n            this.hGame.stage.getTerrain(gridPos.x, gridPos.y) !==\r\n            terrainTypes.Nrm\r\n        )\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    checkMoveDestination(gridPos) {\r\n        if (\r\n            Math.abs(gridPos.x - this.gridPos.x) +\r\n                Math.abs(gridPos.y - this.gridPos.y) >\r\n            this.moveDistMax\r\n        )\r\n            return false;\r\n\r\n        if (this.hGame.pathFinder.isReachable(this.pathData, gridPos)) {\r\n            //this.acceptPath(path);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    acceptPath(path) {\r\n        this.pathToDestProposal = path;\r\n        this.pathToDestProposalCoord = [path.length];\r\n        let len = path.length;\r\n        for (let i = 0; i < len; i++) {\r\n            //alert(i + \",\" + path[i].x + \",\" + path[i].y);\r\n            this.pathToDestProposalCoord[i] = this.hGame.gridPosToPos(path[i]);\r\n        }\r\n    }\r\n\r\n    eventProposeDestination(destGP) {\r\n        this.hasDestProposal = true;\r\n        this.destProposalGP = destGP;\r\n        this.destProposalCoord = this.hGame.gridPosToPos(destGP);\r\n        this.acceptPath(\r\n            this.hGame.pathFinder.retrievePath(\r\n                this.pathData,\r\n                this.gridPos,\r\n                destGP\r\n            )\r\n        );\r\n    }\r\n\r\n    executeAction() {\r\n        this.stamina--;\r\n        this.resetProposal();\r\n        this.hGame.eventActionExecuted();\r\n    }\r\n\r\n    eventExecuteMovement() {\r\n        this.gridPos = this.destProposalGP;\r\n        this.coordinate = this.hGame.gridPosToPos(this.gridPos);\r\n        this.executeAction();\r\n    }\r\n\r\n    checkAttackTarget(unit, destProposalGP) {\r\n        if (\r\n            Math.abs(unit.gridPos.x - destProposalGP.x) +\r\n                Math.abs(unit.gridPos.y - destProposalGP.y) ===\r\n            this.attackRange\r\n        )\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    eventProposeTarget(unit) {\r\n        this.targetProposal = unit;\r\n        this.hasTargetProposal = true;\r\n    }\r\n\r\n    eventBeTargeted() {\r\n        this.isTargeted = true;\r\n    }\r\n\r\n    eventStopBeingTargeted() {\r\n        this.isTargeted = false;\r\n    }\r\n\r\n    eventExecuteAttack(unit) {\r\n        this.gridPos = this.destProposalGP;\r\n        this.coordinate = this.hGame.gridPosToPos(this.gridPos);\r\n        this.hGame.eventBattle(this, unit);\r\n        this.executeAction();\r\n    }\r\n\r\n    eventExecuteWait() {\r\n        this.executeAction();\r\n    }\r\n\r\n    eventLoseHP(damage) {\r\n        this.hp -= damage;\r\n        if (this.hp <= 0) {\r\n            this.alive = false;\r\n            this.hGame.eventUnitDeath(this);\r\n        }\r\n    }\r\n\r\n    isInPhase() {\r\n        return (\r\n            this.isEnemy ===\r\n            (this.hGame.currentPhase === this.hGame.PHASE_ENEMY)\r\n        );\r\n    }\r\n\r\n    update(df) {}\r\n\t\r\n\tdrawThreat(ctx) {\r\n\t\tif (this.isSelected) {\r\n\t\t\tctx.fillStyle = \"rgba(255,238,238,0.8)\";\r\n\t\t\tthis.pathData.listAttackable.forEach(gp => {\r\n\t\t\t\tif (!this.hGame.pathFinder.isReachable(this.pathData, gp)) {\r\n\t\t\t\t\tlet pos = this.hGame.gridPosToPos(gp);\r\n\t\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t\tpos.x - this.imageSize.x * 0.45,\r\n\t\t\t\t\t\tpos.y - this.imageSize.y * 0.45,\r\n\t\t\t\t\t\tthis.imageSize.x * 0.9,\r\n\t\t\t\t\t\tthis.imageSize.y * 0.9\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tctx.fillStyle = \"rgba(238,238,255,0.5)\";\r\n\t\t\tthis.pathData.listPossibleDest.forEach(gp => {\r\n\t\t\t\tlet pos = this.hGame.gridPosToPos(gp);\r\n\t\t\t\tctx.fillRect(\r\n\t\t\t\t\tpos.x - this.imageSize.x * 0.45,\r\n\t\t\t\t\tpos.y - this.imageSize.y * 0.45,\r\n\t\t\t\t\tthis.imageSize.x * 0.9,\r\n\t\t\t\t\tthis.imageSize.y * 0.9\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n    drawUnitBG(ctx) {\r\n        if (this.isSelected || this.isTargeted) {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,85,85,0.9)\";\r\n            else ctx.fillStyle = \"rgba(136,136,238,0.9)\";\r\n        } else if (this.isActive() || !this.isInPhase()) {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,140,140,0.8)\";\r\n            else ctx.fillStyle = \"rgba(170,170,255,0.8)\";\r\n        } else {\r\n            if (this.isEnemy) ctx.fillStyle = \"rgba(255,238,238,0.8)\";\r\n            else ctx.fillStyle = \"rgba(238,238,255,0.8)\";\r\n        }\r\n        ctx.fillRect(\r\n            this.coordinate.x - this.imageSize.x * 0.45,\r\n            this.coordinate.y - this.imageSize.y * 0.45,\r\n            this.imageSize.x * 0.9,\r\n            this.imageSize.y * 0.9\r\n        );\r\n\r\n        if (this.hasDestProposal) {\r\n            if (this.pathToDestProposal !== null) {\r\n                if (this.isEnemy) ctx.fillStyle = \"rgba(255,170,170,0.7)\";\r\n                else ctx.fillStyle = \"rgba(170,204,255,0.7)\";\r\n                let len = this.pathToDestProposal.length;\r\n                for (let i = 1; i < len; i++) {\r\n                    ctx.fillRect(\r\n                        this.pathToDestProposalCoord[i].x -\r\n                            this.imageSize.x * 0.45,\r\n                        this.pathToDestProposalCoord[i].y -\r\n                            this.imageSize.y * 0.45,\r\n                        this.imageSize.x * 0.9,\r\n                        this.imageSize.y * 0.9\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (this.isEnemy) ctx.fillStyle = \"#e88\";\r\n            else ctx.fillStyle = \"#88e\";\r\n            ctx.fillRect(\r\n                this.destProposalCoord.x - this.imageSize.x * 0.45,\r\n                this.destProposalCoord.y - this.imageSize.y * 0.45,\r\n                this.imageSize.x * 0.9,\r\n                this.imageSize.y * 0.9\r\n            );\r\n        }\r\n    }\r\n\r\n    drawUnit(ctx) {\r\n        if (this.hasDestProposal) {\r\n            ctx.drawImage(\r\n                this.image,\r\n                this.destProposalCoord.x -\r\n                    (this.imageSize.x * this.drawScale) / 2,\r\n                this.destProposalCoord.y -\r\n                    (this.imageSize.y * this.drawScale) / 2,\r\n                this.imageSize.x * this.drawScale,\r\n                this.imageSize.y * this.drawScale\r\n            );\r\n        } else {\r\n            ctx.drawImage(\r\n                this.image,\r\n                this.coordinate.x - (this.imageSize.x * this.drawScale) / 2,\r\n                this.coordinate.y - (this.imageSize.y * this.drawScale) / 2,\r\n                this.imageSize.x * this.drawScale,\r\n                this.imageSize.y * this.drawScale\r\n            );\r\n        }\r\n    }\r\n}\r\n","export default class Grid {\r\n    constructor(gridSize, maxGrid) {\r\n        this.gridSize = gridSize;\r\n        this.xMax = maxGrid.x;\r\n        this.yMax = maxGrid.y;\r\n\r\n        this.lineHalfWidth = 1;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.fillStyle = \"#03f\";\r\n        for (let x = 0; x <= this.xMax; x++) {\r\n            ctx.fillRect(\r\n                x * this.gridSize - this.lineHalfWidth,\r\n                0 - this.lineHalfWidth,\r\n                2 * this.lineHalfWidth,\r\n                this.yMax * this.gridSize + 2 * this.lineHalfWidth\r\n            );\r\n        }\r\n\r\n        for (let y = 0; y <= this.yMax; y++) {\r\n            ctx.fillRect(\r\n                0 - this.lineHalfWidth,\r\n                y * this.gridSize - this.lineHalfWidth,\r\n                this.xMax * this.gridSize + 2 * this.lineHalfWidth,\r\n                2 * this.lineHalfWidth\r\n            );\r\n        }\r\n    }\r\n}\r\n","export default class effectStartPhase {\r\n    constructor(hGame, isEnemyPhase) {\r\n        this.frame = 1;\r\n        this.maxFrame = 100;\r\n        this.isEnemyPhase = isEnemyPhase;\r\n        if (isEnemyPhase) this.image = document.getElementById(\"img_effect_EP\");\r\n        else this.image = document.getElementById(\"img_effect_PP\");\r\n        this.drawX = hGame.gameWidth + hGame.gridSize + 20;\r\n        this.drawY =\r\n            (hGame.gridSize * hGame.maxGrid.y) / 2 - this.image.height / 2;\r\n        this.hGame = hGame;\r\n    }\r\n\r\n    update(df) {\r\n        this.frame += df;\r\n        this.drawX -= 18.75 * df;\r\n        if (this.frame > this.maxFrame) this.hGame.eventEffectEnd(this);\r\n    }\r\n\r\n    draw(ctx) {\r\n        if (this.frame <= this.maxFrame)\r\n            ctx.drawImage(this.image, this.drawX, this.drawY);\r\n    }\r\n}\r\n","import AbstractController from \"/src/abstractController\";\r\nimport consts from \"/src/consts\";\r\n\r\n// remember to check 1~maxGrid when using this stuff\r\nconst d1 = [{x:0, y:+1}, {x:-1, y:0}, {x:+1, y:0}, {x:0, y:-1} ];\r\nconst d2 = [{x:0, y:+2}, {x:-1, y:+1}, {x:+1, y:+1}, {x:-2, y:0},\r\n\t\t\t{x:+2, y:0}, {x:-1, y:-1}, {x:+1, y:-1}, {x:0, y:-2}];\r\nconst MAX_DIST = 100000;\r\n\r\nexport default class EnemyAI {\r\n    constructor(hGame, isEnemy) {\r\n        this.hGame = hGame;\r\n\t\tthis.maxGrid = this.hGame.maxGrid;\r\n\t\t\r\n        this.isEnemy = isEnemy;\r\n        if (this.isEnemy) {\r\n            this.suList = hGame.enemyUnitList;\r\n            this.ouList = hGame.playerUnitList;\r\n        } else {\r\n            this.suList = hGame.playerUnitList;\r\n            this.ouList = hGame.enemyUnitList;\r\n        }\r\n\r\n        this.absCon = new AbstractController(this.hGame, isEnemy);\r\n\r\n        this.blockFrameRemain = 0;\r\n        this.blockFramePerAttack = 18;\r\n        this.blockFramePerMove = 18;\r\n        this.blockFramePerWait = 5;\r\n    }\r\n\r\n    executeWait(unit) {\r\n        this.absCon.clickGP(unit.gridPos);\r\n        this.absCon.clickButton(consts.buttons.Wait);\r\n\t\tthis.absCon.clickButton(consts.buttons.Wait);\r\n        this.blockFrameRemain = this.blockFramePerWait;\r\n    }\r\n\r\n    executeMove(unit, dest) {\r\n        this.absCon.clickGP(unit.gridPos);\r\n        this.absCon.clickGP(dest);\r\n        this.absCon.clickGP(dest);\r\n        this.blockFrameRemain = this.blockFramePerMove;\r\n    }\r\n\r\n    executeMoveAttack(unit, dest, target) {\r\n        //alert(unit.gridPos.x + \", \" + unit.gridPos.y + \" @ \" + dest.x + \", \" + dest.y + \" vs \"+ target.gridPos.x + \", \" + target.gridPos.y);\r\n        this.absCon.clickGP(unit.gridPos);\r\n        if (dest.x === unit.gridPos.x && dest.y === unit.gridPos.y) {\r\n            this.absCon.clickGP(target.gridPos);\r\n            this.absCon.clickGP(target.gridPos);\r\n        } else {\r\n            this.absCon.clickGP(dest);\r\n            this.absCon.clickGP(target.gridPos);\r\n            this.absCon.clickGP(target.gridPos);\r\n        }\r\n        this.blockFrameRemain = this.blockFramePerAttack;\r\n    }\r\n\t\r\n\tcheckIfGpInMaxGrid(x, y) {\r\n\t\tif (x < 1 || y < 1 || x > this.maxGrid.x || y > this.maxGrid.y) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfindBestAttackPosition(su, target) {\r\n\t\tlet dAttacks = (su.attackRange === 1) ? d1 : d2;\r\n\t\t\r\n\t\tlet minDist = MAX_DIST;\r\n\t\tlet bestGP = null;\r\n\t\tdAttacks.forEach(dgp => {\r\n\t\t\tif (this.checkIfGpInMaxGrid(target.gridPos.x + dgp.x, target.gridPos.y + dgp.y) &&\r\n\t\t\t\tsu.pathData.dist[target.gridPos.x + dgp.x][target.gridPos.y + dgp.y] < minDist\r\n\t\t\t) {\r\n\t\t\t\tminDist = su.pathData.dist[target.gridPos.x + dgp.x][target.gridPos.y + dgp.y];\r\n\t\t\t\tbestGP = {x : target.gridPos.x+dgp.x,  y : target.gridPos.y+dgp.y};\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t//alert(\"/findBestAttackPosition \" + su.unitID + \",\" + target.unitID +\" @(\" + bestGP.x +\",\"+bestGP.y + \")\");\r\n\t\t\r\n\t\treturn bestGP;\r\n\t}\r\n\r\n    findOppoUnitAndAttack(suIdx) {\r\n        let su = this.suList[suIdx];\r\n\t\tlet flagDone = false;\r\n\t\t\r\n        su.pathData.listAttackable.forEach(gp => {\r\n\t\t\tif (flagDone) return;\r\n\t\t\tlet target = this.hGame.findOppoUnitByGridPos(this.isEnemy, gp);\r\n\t\t\tif (target !== null) {\r\n\t\t\t\t//alert(\"found target\");\r\n\t\t\t\tthis.executeMoveAttack(\r\n\t\t\t\t\tsu, \r\n\t\t\t\t\tthis.findBestAttackPosition(su, target), \r\n\t\t\t\t\ttarget\r\n\t\t\t\t);\r\n\t\t\t\tflagDone = true;\r\n\t\t\t\treturn; // you can't just return true here because it's inside a anonymous func\r\n\t\t\t\t\t\t// and you can't assume fOUAA ends here because it's inside a forEach loop!\r\n\t\t\t\t\t\t// the moral is: old for loop RULES\r\n            }\r\n        });\r\n        return flagDone;\r\n    }\r\n\r\n    tryGetClose(suIdx) {\r\n        let su = this.suList[suIdx];\r\n        if (su.pathData.listPossibleDest.length === 0) return false;\r\n\r\n        let minDist = 10000;\r\n        let bestGP = null;\r\n        su.pathData.listPossibleDest.forEach(gp => {\r\n            if (this.hGame.findSelfUnitByGridPos(this.isEnemy, gp) !== null)\r\n                return;\r\n            //alert(\"gp: \" + gp.x + \",\" + gp.y);\r\n            let wideSearch = this.hGame.pathFinder.floodFill(su, gp, 300, true);\r\n            this.ouList.forEach(target => {\r\n                let distTarget =\r\n                    wideSearch.dist[target.gridPos.x][target.gridPos.y];\r\n                //alert(target.unitID + \",\" + distTarget);\r\n                if (distTarget < minDist) {\r\n                    minDist = distTarget;\r\n                    bestGP = gp;\r\n                }\r\n            });\r\n        });\r\n        //alert(minDist + \", \" + bestGP);\r\n        if (bestGP !== null) {\r\n            this.executeMove(su, bestGP);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    makeOneMove() {\r\n        let i = 0,\r\n            len = this.suList.length;\r\n        for (i = 0; i < len; i++) {\r\n            if (this.suList[i].stamina > 0) {\r\n                let res = this.findOppoUnitAndAttack(i);\r\n                if (res === false) res = this.tryGetClose(i);\r\n                if (res === false) this.executeWait(this.suList[i]);\r\n\t\t\t\t\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    update(df) {\r\n        this.blockFrameRemain -= df;\r\n        if (this.blockFrameRemain <= 0) {\r\n            this.makeOneMove();\r\n        }\r\n    }\r\n}\r\n","const dx = [0, -1, +1, 0];\r\nconst dy = [+1, 0, 0, -1];\r\nconst d1 = [{x:0, y:+1}, {x:-1, y:0}, {x:+1, y:0}, {x:0, y:-1} ];\r\nconst d2 = [{x:0, y:+2}, {x:-1, y:+1}, {x:+1, y:+1}, {x:-2, y:0},\r\n\t\t\t{x:+2, y:0}, {x:-1, y:-1}, {x:+1, y:-1}, {x:0, y:-2}];\r\nconst MAX_DIST = 100000;\r\n\r\nexport default class PathFinder {\r\n    constructor(hGame) {\r\n        this.hGame = hGame;\r\n        this.maxGrid = hGame.maxGrid;\r\n        this.eList = hGame.enemyUnitList;\r\n        this.pList = hGame.playerUnitList;\r\n        this.hStage = hGame.stage;\r\n\r\n        this.visited = null;\r\n        this.path = null;\r\n    }\r\n\r\n    /* \r\n        Main service of PathFinder.\r\n        return an object pathData := {\r\n\t\t\tprev[x][y] := (gp) gp of parent node in the path tree.\r\n\t\t\tdist[x][y] := (int) dist from startGP.\r\n\t\t\tlistPossibleDest := [] of reachable gp.\r\n\t\t\tattackable[x][y] := (bool) whether that gp can be attacked by the unit.\r\n\t\t\tlistAttackable := [] of attackable gp.\r\n\t\t}\r\n    */\r\n    floodFill(unit, startGP, searchRange, flagIgnoreUnit = false) {\r\n        let prev = [this.maxGrid.x + 1];\r\n        let dist = [this.maxGrid.x + 1];\r\n\t\tlet attackable = [this.maxGrid.x + 1];\r\n        for (let i = 1; i <= this.maxGrid.x; i++) {\r\n            prev[i] = [this.maxGrid.y + 1];\r\n            dist[i] = [this.maxGrid.y + 1];\r\n            attackable[i] = [this.maxGrid.y + 1];\r\n            for (let j = 1; j <= this.maxGrid.y; j++) {\r\n                dist[i][j] = MAX_DIST;\r\n                prev[i][j] = null;\r\n                attackable[i][j] = false;\r\n            }\r\n        }\r\n\r\n        let queue = [];\r\n        let head = 1,\r\n            tail = 0;\r\n        queue[head] = startGP;\r\n        prev[startGP.x][startGP.y] = startGP;\r\n        dist[startGP.x][startGP.y] = 0;\r\n        let listPossibleDest = [];\r\n        listPossibleDest.push(startGP);\r\n\t\tlet listAttackable = [];\r\n\t\t\r\n\t\tlet dAttacks = (unit.attackRange === 1) ? d1 : d2;\r\n\t\tthis.addAttackable(dAttacks, attackable, listAttackable, startGP.x, startGP.y)\r\n\r\n        while (head > tail) {\r\n            tail++;\r\n            if (dist[queue[tail].x][queue[tail].y] >= searchRange) continue;\r\n            for (let i = 0; i < 4; i++) {\r\n                let xNew = queue[tail].x + dx[i];\r\n                let yNew = queue[tail].y + dy[i];\r\n                if (\r\n                    xNew >= 1 &&\r\n                    xNew <= this.maxGrid.x &&\r\n                    yNew >= 1 &&\r\n                    yNew <= this.maxGrid.y &&\r\n                    dist[xNew][yNew] === MAX_DIST\r\n                ) {\r\n                    let gpNew = { x: xNew, y: yNew };\r\n                    if (unit.checkPassable(gpNew, flagIgnoreUnit)) {\r\n                        head++;\r\n                        queue[head] = gpNew;\r\n                        dist[xNew][yNew] = dist[queue[tail].x][queue[tail].y] + 1;\r\n                        prev[xNew][yNew] = queue[tail];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.addAttackable(dAttacks, attackable, listAttackable, xNew, yNew);\r\n\t\t\t\t\t\t\r\n                        listPossibleDest.push(gpNew);\r\n                    }\r\n                    //alert(xNew + \",\" + yNew + \",\" + dist[xNew][yNew]);\r\n                }\r\n            }\r\n        }\r\n        let pathData = { \r\n\t\t\tprev: prev, \r\n\t\t\tdist: dist, \r\n\t\t\tlistPossibleDest: listPossibleDest,\r\n\t\t\tattackable: attackable,\r\n\t\t\tlistAttackable: listAttackable\r\n\t\t};\r\n\t\treturn pathData;\r\n    }\r\n\r\n    /*\r\n        Minor service. Tells from pathData whether goalGP is reachable.\r\n    */\r\n    isReachable(pathData, goalGP) {\r\n        return pathData.dist[goalGP.x][goalGP.y] !== MAX_DIST;\r\n    }\r\n\r\n    /*\r\n        Main service. Extract the path starting from startGP to goalGP\r\n        from pathData. \r\n        path[0] should always be startGP if done correctly.\r\n        goalGP is NOT included in the path.\r\n    */\r\n    retrievePath(pathData, startGP, goalGP) {\r\n        let prev = pathData.prev;\r\n        if (prev[goalGP.x][goalGP.y] !== null) {\r\n            let x = goalGP.x,\r\n                y = goalGP.y;\r\n            let dist = 0;\r\n            //alert(x + \",\" + y);\r\n            while (x !== startGP.x || y !== startGP.y) {\r\n                dist++;\r\n                let xNew = prev[x][y].x;\r\n                y = prev[x][y].y;\r\n                x = xNew;\r\n                //alert(x + \",\" + y);\r\n            }\r\n            let path = [dist];\r\n            x = goalGP.x;\r\n            y = goalGP.y;\r\n            for (let i = 0; i < dist; i++) {\r\n                path[dist - i - 1] = prev[x][y];\r\n                let xNew = prev[x][y].x;\r\n                y = prev[x][y].y;\r\n                x = xNew;\r\n            }\r\n            return path;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\t// unused\r\n    findPath(unit, startGP, goalGP) {\r\n        let pathData = this.floodFill(unit, startGP, unit.moveDist);\r\n        //alert(startGP.x + \",\" + startGP.y + \",\" + goalGP.x + \",\" + goalGP.y);\r\n        return this.retrievePath(pathData, startGP, goalGP);\r\n    }\r\n\t\r\n\t// private methods\r\n\tcheckIfGpInMaxGrid(x, y) {\r\n\t\tif (x < 1 || y < 1 || x > this.maxGrid.x || y > this.maxGrid.y) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\taddAttackable(dAttacks, attackable, listAttackable, xOrigin, yOrigin)\r\n\t{\r\n\t\tdAttacks.forEach(dgp => {\r\n\t\t\t//alert(dgp.x +\",\"+ dgp.y +\",\"+ xOrigin +\",\"+  yOrigin)\r\n\t\t\tif (this.checkIfGpInMaxGrid(xOrigin + dgp.x, yOrigin + dgp.y) &&\r\n\t\t\t\t!attackable[xOrigin + dgp.x][yOrigin + dgp.y]\r\n\t\t\t) {\r\n\t\t\t\tattackable[xOrigin + dgp.x][yOrigin + dgp.y] = true;\r\n\t\t\t\tlistAttackable.push({\r\n\t\t\t\t\tx : xOrigin + dgp.x, y : yOrigin + dgp.y\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n","import consts from \"/src/consts\";\r\nlet T = consts.terrainTypes;\r\n\r\nexport default class Stage {\r\n    constructor(maxGrid, terrainMap, unitList) {\r\n        this.maxGrid = maxGrid;\r\n        this.terrainMap = terrainMap; // NOTE: use it as [y-1][x-1] !! or getTerrain(x,y)\r\n        this.unitList = unitList;\r\n\r\n        this.imageCache = [];\r\n        this.hGame = null; // should not be initialised in constructor because it's called by stage scripts rather than game\r\n    }\r\n\r\n    initStage(hGame) {\r\n        this.hGame = hGame;\r\n        // push stuffs into game by calling events\r\n        this.unitList.forEach(unit => {\r\n            if (unit.appearTurn === 0)\r\n                hGame.eventPlaceUnit(unit.gridPos, unit.isEnemy, unit.image);\r\n        });\r\n\r\n        this.imageCache[T.Nrm] = document.getElementById(\"img_terrain_grass\");\r\n        this.imageCache[T.Mnt] = document.getElementById(\"img_terrain_yama\");\r\n        this.imageCache[T.Wtr] = document.getElementById(\"img_terrain_kawa\");\r\n    }\r\n\r\n    endTurn(hGame) {\r\n        this.unitList.forEach(unit => {\r\n            if (\r\n                unit.appearTurn === hGame.turn &&\r\n                unit.isEnemy === (hGame.currentPhase === hGame.PHASE_ENEMY)\r\n            )\r\n                hGame.eventPlaceUnit(unit.gridPos, unit.isEnemy, unit.image);\r\n        });\r\n    }\r\n\r\n    getTerrain(x, y) {\r\n        return this.terrainMap[y - 1][x - 1];\r\n    }\r\n\r\n    update(df) {}\r\n\r\n    draw(ctx) {\r\n        for (let i = 1; i <= this.maxGrid.x; i++) {\r\n            for (let j = 1; j <= this.maxGrid.y; j++) {\r\n                let pos = this.hGame.gridPosToPos({ x: i, y: j });\r\n                //alert(i + \",\" + j + \", \" + [this.terrainMap[j][i]]);\r\n                ctx.drawImage(\r\n                    this.imageCache[this.getTerrain(i, j)],\r\n                    pos.x - this.hGame.gridSize / 2,\r\n                    pos.y - this.hGame.gridSize / 2,\r\n                    this.hGame.gridSize,\r\n                    this.hGame.gridSize\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n","import Stage from \"/src/stage\";\r\nimport consts from \"/src/consts\";\r\n\r\nlet T = consts.terrainTypes;\r\n\r\nlet maxGrid = { x: 6, y: 8 };\r\nlet terrainMap = [\r\n    [T.Nrm, T.Mnt, T.Mnt, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Wtr],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Mnt, T.Mnt, T.Nrm]\r\n];\r\n\r\nlet unitList = [\r\n    {\r\n        gridPos: { x: 3, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n\r\n    {\r\n        gridPos: { x: 4, y: 2 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    }\r\n];\r\n\r\nexport default function createStage()\t{\r\n\treturn new Stage(maxGrid, terrainMap, unitList);\r\n}\r\n","import Stage from \"/src/stage\";\r\nimport consts from \"/src/consts\";\r\n\r\nlet T = consts.terrainTypes;\r\n\r\nlet maxGrid = { x: 6, y: 8 };\r\nlet terrainMap = [\r\n    [T.Nrm, T.Mnt, T.Mnt, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Wtr],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Wtr, T.Nrm, T.Mnt],\r\n    [T.Nrm, T.Wtr, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm, T.Nrm],\r\n    [T.Nrm, T.Nrm, T.Nrm, T.Mnt, T.Mnt, T.Nrm]\r\n];\r\n\r\nlet unitList = [\r\n    {\r\n        gridPos: { x: 2, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 4, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n    {\r\n        gridPos: { x: 5, y: 7 },\r\n        appearTurn: 0,\r\n        isEnemy: false,\r\n        image: \"img_kenshi\"\r\n    },\r\n\r\n    {\r\n        gridPos: { x: 1, y: 1 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 2 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 4, y: 1 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 3, y: 4 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    },\r\n    {\r\n        gridPos: { x: 5, y: 2 },\r\n        appearTurn: 0,\r\n        isEnemy: true,\r\n        image: \"img_kenshi2\"\r\n    }\r\n];\r\n\r\nexport default function createStage()\t{\r\n\treturn new Stage(maxGrid, terrainMap, unitList);\r\n}\r\n","let BUTTON_OFFSET_X = 10;\r\n\r\nexport default class Button {\r\n\tconstructor (hGame, imgString, id, drawGP) {\r\n\t\tthis.hGame = hGame;\r\n\t\tthis.img = document.getElementById(imgString);\r\n\t\t\r\n\t\tthis.buttonID = id;\r\n\t\tthis.drawGP = drawGP;\r\n\t\t\r\n\t\tthis.pos = this.hGame.gridPosToPos(drawGP);\r\n\t\t//alert(this.pos.x + \", \" +this.pos.y);\r\n\t\t\r\n\t\tthis.drawScale = 1;\r\n\t\tthis.drawScaleMax = 1;\r\n\t\t\r\n\t}\r\n\t\r\n\tcheckClick(pos) {\r\n\t\tif (pos.x >= BUTTON_OFFSET_X + this.pos.x - this.hGame.gridSize * this.drawScale * 0.5\r\n\t\t\t&& pos.y >= this.pos.y - this.hGame.gridSize * this.drawScale * 0.5\r\n\t\t\t&& pos.x <= BUTTON_OFFSET_X + this.pos.x + this.hGame.gridSize * this.drawScale * 0.5\r\n\t\t\t&& pos.y <= this.pos.y + this.hGame.gridSize * this.drawScale * 0.5\r\n\t\t)\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\teventClick() {\r\n\t\tthis.drawScale = 0.7;\r\n\t}\r\n\t\r\n\tupdate(df) {\r\n\t\tif (this.drawScale < this.drawScaleMax)\r\n\t\t\tthis.drawScale = Math.min(this.drawScale + df * 0.02, this.drawScaleMax);\r\n\t}\r\n\t\r\n\tdraw(ctx) {\r\n\t\tctx.drawImage(\r\n\t\t\tthis.img, \r\n\t\t\tBUTTON_OFFSET_X + this.pos.x - this.hGame.gridSize * this.drawScale * 0.5, \r\n\t\t\tthis.pos.y - this.hGame.gridSize * this.drawScale * 0.5, \r\n\t\t\tthis.hGame.gridSize*this.drawScale,\r\n\t\t\tthis.hGame.gridSize*this.drawScale\r\n\t\t);\r\n\t}\r\n}","import UnitBase from \"/src/unitBase\";\r\nimport Grid from \"/src/grid\";\r\nimport EffectStartPhase from \"/src/effects/effectStartPhase\";\r\nimport EnemyAI from \"/src/enemyAI\";\r\nimport PathFinder from \"/src/pathFinder\";\r\nimport Stage00 from \"/src/stages/stage00\";\r\nimport Stage01 from \"/src/stages/stage01\";\r\nimport consts from \"/src/consts\";\r\nimport Button from \"/src/button\";\r\n\r\nexport default class Game {\r\n    constructor(gameWidth, gameHeight, canvas) {\r\n        this.PHASE_NONE = 0;\r\n        this.PHASE_PLAYER = 1;\r\n        this.PHASE_ENEMY = 2;\r\n\r\n        this.gameWidth = gameWidth;\r\n        this.gameHeight = gameHeight;\r\n        this.hCanvas = canvas;\r\n\r\n        this.maxGrid = { x: 6, y: 8 };\r\n\r\n        this.gridSize = gameWidth / this.maxGrid.x;\r\n        this.grid = new Grid(this.gridSize, this.maxGrid);\r\n\t\r\n\t\tthis.buttonList = [];\r\n\t\tthis.makeButtons();\r\n\t\t\r\n\t\tthis.resetGameState()\r\n    }\r\n\t\r\n\tresetGameState() {\r\n        this.playerUnitList = [];\r\n        this.enemyUnitList = [];\r\n        this.unitID = 0;\r\n\r\n        this.effectList = [];\r\n\r\n        this.totalActiveStamina = 0;\r\n        this.currentPhase = this.PHASE_NONE;\r\n        this.isPhaseBlocked = false;\r\n        this.framesBeforeChangePhase = 0;\r\n\r\n        this.turn = 0;\r\n        this.stage = null;\r\n        this.enemyAI = new EnemyAI(this, true);\r\n        this.pathFinder = new PathFinder(this);\r\n\r\n        this.gameResult = consts.gameResult.None;\t\r\n\t}\r\n\t\r\n\tmakeButtons() {\r\n\t\tthis.buttonList.push(new Button(\r\n\t\t\tthis, \"img_button_wait\", consts.buttons.Wait, {x:7, y:1}\r\n\t\t));\r\n\t\tthis.buttonList.push(new Button(\r\n\t\t\tthis, \"img_button_turn_end\", consts.buttons.TurnEnd, {x:7, y:2}\r\n\t\t));\r\n\t}\r\n\r\n    bindPlayerInputHandler(inputHandler) {\r\n        this.playerInputHandler = inputHandler;\r\n    }\r\n\r\n    eventPlaceUnit(gridPos, isEnemy, image) {\r\n        this.unitID++;\r\n        if (isEnemy)\r\n            this.enemyUnitList.push(\r\n                new UnitBase(this.unitID, this, gridPos, isEnemy, image)\r\n            );\r\n        else\r\n            this.playerUnitList.push(\r\n                new UnitBase(this.unitID, this, gridPos, isEnemy, image)\r\n            );\r\n    }\r\n\r\n    start(stageIdxStr) {\r\n\t\t//alert(\"start\")\r\n\t\tthis.resetGameState();\r\n\t\t\r\n\t\tif (stageIdxStr === \"00\") this.stage = Stage00();\r\n\t\tif (stageIdxStr === \"01\") this.stage = Stage01();\r\n\t\t\t\t\r\n        this.stage.initStage(this);\r\n\t\t\r\n        this.playerPhase();\r\n\t\tthis.requirePathUpdate();\r\n    }\r\n\r\n\trequirePathUpdate() {\r\n\t\tthis.playerUnitList.forEach(object => object.eventRequirePathUpdate());\r\n        this.enemyUnitList.forEach(object => object.eventRequirePathUpdate());\r\n\t}\r\n\r\n    eventActionExecuted() {\r\n        this.totalActiveStamina--;\r\n        if (this.totalActiveStamina <= 0) {\r\n            this.endPhase();\r\n        }\r\n        \r\n\t\tthis.requirePathUpdate();\r\n    }\r\n\r\n\teventButtonTurnEnd() {\r\n\t\tlet list = (this.currentPhase === this.PHASE_PLAYER) ? \r\n\t\t\tthis.playerUnitList : this.enemyUnitList;\r\n\t\t\r\n\t\tlist.forEach(unit => {\r\n\t\t\tif (unit.isActive()) unit.eventExecuteWait();\r\n\t\t});\r\n\r\n\t}\r\n\r\n    playerPhase() {\r\n        //alert(\"Player Phase\");\r\n        this.turn++;\r\n        this.currentPhase = this.PHASE_PLAYER;\r\n        this.totalActiveStamina = 0;\r\n        this.playerUnitList.forEach(object => {\r\n            object.eventNewTurn();\r\n            this.totalActiveStamina += object.stamina;\r\n        });\r\n    }\r\n\r\n    enemyPhase() {\r\n        //alert(\"Enemy Phase\");\r\n        this.currentPhase = this.PHASE_ENEMY;\r\n        this.totalActiveStamina = 0;\r\n        this.enemyUnitList.forEach(object => {\r\n            object.eventNewTurn();\r\n            this.totalActiveStamina += object.stamina;\r\n        });\r\n        //this.endPhase();\r\n    }\r\n\r\n    endPhase() {\r\n        this.stage.endTurn(this);\r\n        this.framesBeforeChangePhase = 80;\r\n        this.isPhaseBlocked = true;\r\n        if (this.currentPhase === this.PHASE_PLAYER) {\r\n            this.effectList.push(new EffectStartPhase(this, true));\r\n        } else {\r\n            this.effectList.push(new EffectStartPhase(this, false));\r\n        }\r\n    }\r\n\r\n    procChangePhase(df) {\r\n        this.framesBeforeChangePhase -= df;\r\n        if (this.framesBeforeChangePhase <= 0) {\r\n            this.isPhaseBlocked = false;\r\n            if (this.currentPhase === this.PHASE_PLAYER) {\r\n                this.enemyPhase();\r\n            } else if (this.currentPhase === this.PHASE_ENEMY) {\r\n                this.playerPhase();\r\n            }\r\n        }\r\n    }\r\n\r\n    findUnitInListByGridPos(unitList, gridPos) {\r\n        let len = unitList.length;\r\n        for (let i = 0; i < len; i++) {\r\n            if (\r\n                unitList[i].gridPos.x === gridPos.x &&\r\n                unitList[i].gridPos.y === gridPos.y\r\n            ) {\r\n                return unitList[i]; // only one unit should be triggered\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPlayerUnitByGridPos(gridPos) {\r\n        //alert(gridPos.x + \", \" + gridPos.y);\r\n        return this.findUnitInListByGridPos(this.playerUnitList, gridPos);\r\n    }\r\n\r\n    findEnemyUnitByGridPos(gridPos) {\r\n        return this.findUnitInListByGridPos(this.enemyUnitList, gridPos);\r\n    }\r\n\r\n    findSelfUnitByGridPos(isEnemy, gridPos) {\r\n        if (isEnemy) return this.findEnemyUnitByGridPos(gridPos);\r\n        else return this.findPlayerUnitByGridPos(gridPos);\r\n    }\r\n\r\n    findOppoUnitByGridPos(isEnemy, gridPos) {\r\n        if (isEnemy) return this.findPlayerUnitByGridPos(gridPos);\r\n        else return this.findEnemyUnitByGridPos(gridPos);\r\n    }\r\n\r\n    findUnitByGridPos(gridPos) {\r\n        let unit = this.findPlayerUnitByGridPos(gridPos);\r\n        if (unit !== null) return unit;\r\n        unit = this.findEnemyUnitByGridPos(gridPos);\r\n        if (unit !== null) return unit;\r\n        return null;\r\n    }\r\n\r\n\tfindButton(pos) {\r\n\t\tlet result = null;\r\n\t\tthis.buttonList.forEach(button => {\r\n\t\t\tif (button.checkClick(pos)) {\r\n\t\t\t\tresult = button.buttonID;\r\n\t\t\t\tbutton.eventClick();\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n    mouseClick(pos) {\r\n        // do nothing\r\n    }\r\n\r\n    eventBattle(attacker, target) {\r\n        target.eventLoseHP(attacker.attack);\r\n    }\r\n\r\n    eventUnitDeath(unit) {\r\n        if (unit.isEnemy) removeObjectFromList(unit, this.enemyUnitList);\r\n        else removeObjectFromList(unit, this.playerUnitList);\r\n\r\n        if (this.enemyUnitList.length <= 0)\r\n            this.gameResult = consts.gameResult.Win;\r\n        else if (this.playerUnitList.length <= 0) {\r\n            this.gameResult = consts.gameResult.Lose;\r\n        }\r\n    }\r\n\r\n    eventEffectEnd(effect) {\r\n        removeObjectFromList(effect, this.effectList);\r\n    }\r\n\r\n    update(df) {\r\n\t\tthis.buttonList.forEach(object => object.update(df));\r\n\t\t\r\n        if (this.framesBeforeChangePhase > 0) this.procChangePhase(df);\r\n        if (this.currentPhase === this.PHASE_ENEMY) this.enemyAI.update(df);\r\n        this.playerInputHandler.update(df);\r\n\r\n        this.playerUnitList.forEach(object => object.update(df));\r\n        this.enemyUnitList.forEach(object => object.update(df));\r\n\t\t\r\n        this.effectList.forEach(object => object.update(df));\r\n\t\t\r\n\t\tif (this.gameResult === consts.gameResult.Win) {\r\n\t\t\talert(\"You win!\");\r\n\t\t\tthis.gameResult = consts.gameResult.GameEnded;\r\n\t\t}\r\n\t\tif (this.gameResult === consts.gameResult.Lose) {\r\n\t\t\talert(\"GAME OVER\");\r\n\t\t\tthis.gameResult = consts.gameResult.GameEnded;\r\n\t\t}\r\n\r\n    }\r\n\r\n    draw(ctx) {\r\n        this.stage.draw(ctx);\r\n\t\tthis.buttonList.forEach(object => object.draw(ctx));\r\n        this.grid.draw(ctx);\r\n\t\t\r\n\t\tthis.playerUnitList.forEach(object => object.drawThreat(ctx));\r\n        this.enemyUnitList.forEach(object => object.drawThreat(ctx));\r\n        this.playerUnitList.forEach(object => object.drawUnitBG(ctx));\r\n        this.enemyUnitList.forEach(object => object.drawUnitBG(ctx));\r\n        this.playerUnitList.forEach(object => object.drawUnit(ctx));\r\n        this.enemyUnitList.forEach(object => object.drawUnit(ctx));\r\n\r\n        this.effectList.forEach(object => object.draw(ctx));\r\n\r\n        if (this.gameResult !== consts.gameResult.None) {\r\n            //alert(\"oxoxoxox\");\r\n        }\r\n    }\r\n\r\n    gridPosToPos(gridPos) {\r\n        return {\r\n            x: gridPos.x * this.gridSize - this.gridSize / 2,\r\n            y: gridPos.y * this.gridSize - this.gridSize / 2\r\n        };\r\n    }\r\n\r\n    posToGridPos(pos) {\r\n        return {\r\n            x: Math.floor(pos.x / this.gridSize) + 1,\r\n            y: Math.floor(pos.y / this.gridSize) + 1\r\n        };\r\n    }\r\n}\r\n\r\nfunction removeObjectFromList(object, list) {\r\n    let len = list.length,\r\n        i = 0;\r\n    for (i = 0; i < len; i++) {\r\n        if (list[i] === object) break;\r\n    }\r\n    list.splice(i, 1);\r\n}\r\n","export default class MapSelecter {\r\n\tconstructor (hGame) {\r\n\t\tlet divSelecter = document.getElementById(\"mapSelecter\");\r\n\r\n\t\tdivSelecter.innerHTML = `\r\n\t\tMap:\r\n\t\t<select id=\"divSelecter_list\">\r\n\t\t\t<option value=\"00\">Stage 00</option>\r\n\t\t\t<option value=\"01\" selected>Stage 01</option>\r\n\t\t</select>\r\n\t\t<button id=\"divSelecter_confirm\">Confirm</button>\r\n\t\t`;\r\n\t\t\r\n\t\tlet button = document.getElementById(\"divSelecter_confirm\");\r\n\t\tbutton.addEventListener(\"click\", event => {\r\n\t\t\tvar e = document.getElementById(\"divSelecter_list\");\r\n\t\t\tvar result = e.options[e.selectedIndex].value;\r\n\t\t\t//alert(\"confirmed\");\r\n\t\t\thGame.start(result);\r\n\t\t});\r\n\r\n\t}\r\n}","import InputHandler from \"/src/inputHandler\";\nimport Game from \"/src/game\";\nimport MapSelecter from \"/src/mapSelecter\";\nimport consts from \"/src/consts\";\n\nlet canvas = document.getElementById(\"gameScreen\");\nlet ctx = canvas.getContext(\"2d\");\n\nconst GAME_WIDTH = 360;\nconst GAME_HEIGHT = 640;\nconst DRAW_WIDTH = 430;\nconst DRAW_HEIGHT = 640;\n\n//let paddle = new Paddle(GAME_WIDTH, GAME_HEIGHT);\n\nlet game = new Game(GAME_WIDTH, GAME_HEIGHT, canvas);\nlet playerInputHandler = new InputHandler(game);\ngame.bindPlayerInputHandler(playerInputHandler);\n\nlet mapSelecter = new MapSelecter(game);\n\ngame.start(\"01\");\n\nlet lastTime = 0;\nfunction gameLoop(timestamp) {\n    let dt = timestamp - lastTime;\n    lastTime = timestamp;\n    let df = dt / 16; // assume 16 ms per frame\n\n    ctx.clearRect(0, 0, DRAW_WIDTH, DRAW_HEIGHT);\n    game.update(df);\n    game.draw(ctx);\n\n\trequestAnimationFrame(gameLoop);\n}\n\nfunction scriptCollapsibles() {\n\t// https://www.w3schools.com/howto/tryit.asp?filename=tryhow_js_collapsible\n\tlet collapsibles = document.getElementsByClassName(\"collapsible\");\n\tfor (let i = 0; i < collapsibles.length; i++) {\n\t\tcollapsibles[i].addEventListener(\"click\", function() {\n\t\t\tthis.classList.toggle(\"active\");\n\t\t\tlet content = this.nextElementSibling; // wtf this is handy\n\t\t\tif (content.style.display === \"block\") {\n\t\t\t\tcontent.style.display = \"none\";\n\t\t\t} else {\n\t\t\t\tcontent.style.display = \"block\";\n\t\t\t}\n\t\t});\n\t}\n}\n\nscriptCollapsibles() ;\n\nrequestAnimationFrame(gameLoop);\n"]}